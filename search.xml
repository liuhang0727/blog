<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式_工厂模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-参考链接"><a href="#0-参考链接" class="headerlink" title="0 参考链接"></a>0 参考链接</h2><p><a href="https://www.bilibili.com/video/BV1e54y1X7bE?from=search&seid=16085648626900326892" target="_blank" rel="noopener">链接_视频</a><br><a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">链接_文档</a>  </p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>工厂模式，Factory Pattern。  </p>
<a id="more"></a>  

<p><code>意图：</code>创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来只当新创建对象。定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><code>主要解决：</code>接口选择的问题。<br><code>何时使用：</code>我们明确地计划不同条件下创建不同实例时。<br><code>如何解决：</code>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><code>关键代码：</code>创建过程在其子类执行。<br><code>优点：</code>  </p>
<ul>
<li>调用者想创建一个对象，只要知道其名称即可。  </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类即可。  </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。  </li>
</ul>
<p><code>使用场景：</code>  </p>
<ul>
<li>日志记录器，记录可能记录到本地硬盘，系统事件或远程服务器等，用户可以选择记录日志到什么地方。  </li>
<li>设计一个连接服务器的框架，需要三个协议，<code>POP3</code>，<code>IMAP</code>和<code>HTTP</code>，可以把三个作为产品类，共同实现一个接口。  </li>
</ul>
<p><code>Highlight：</code>  </p>
<ul>
<li>创建复杂对象适合使用工厂模式，而简单对象，特别是只需要通过<code>new</code>就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，增加系统的复杂度。(<code>So, what is 复杂对象 ??</code>)  </li>
</ul>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><h3 id="2-0-case-0-子类数据成员一致"><a href="#2-0-case-0-子类数据成员一致" class="headerlink" title="2.0 case_0: 子类数据成员一致"></a>2.0 case_0: 子类数据成员<code>一致</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类Color，接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字virtual修饰，虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Red继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Red"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Green继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Green"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类，生成对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字static修饰，定位为类的静态方法，调用时不需要有类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Color* <span class="title">getColor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">"Red"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">"Green"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pRed</span><span class="params">(Factory::getColor(<span class="string">"Red"</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pGreen</span><span class="params">(Factory::getColor(<span class="string">"Green"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRed != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pRed-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pGreen != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pGreen-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-case-1-子类数据成员不一致"><a href="#2-1-case-1-子类数据成员不一致" class="headerlink" title="2.1 case_1: 子类数据成员不一致"></a>2.1 case_1: 子类数据成员<code>不一致</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类Color，接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字virtual修饰，虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Red继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Red(<span class="built_in">std</span>::<span class="built_in">string</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        : a_(<span class="built_in">std</span>::<span class="built_in">move</span>(a)), b_(b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ &lt;&lt; <span class="string">", "</span> &lt;&lt; b_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Green继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Green(<span class="built_in">std</span>::<span class="built_in">string</span> a)</span><br><span class="line">        : a_(<span class="built_in">std</span>::<span class="built_in">move</span>(a)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂不一定需要是类，一个函数也可以</span></span><br><span class="line"><span class="comment">// 泛型，模板</span></span><br><span class="line"><span class="comment">// 参数个数不定, typename ... Args可变参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Object, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">Color* <span class="title">factoryColor</span><span class="params">(<span class="keyword">typename</span> ... Args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(args ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pRed</span><span class="params">(factoryColor(<span class="string">"Red"</span>, <span class="number">666</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pGreen</span><span class="params">(factoryColor(<span class="string">"Green"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRed != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pRed-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pGreen != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pGreen-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><p><code>设计模式</code> (<code>Design Pattern</code>) 代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用。<br>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，是众多软件开发人员经过相当长一段时间的试验和错误总结出来的。<br>设计模式是一套被反复使用的，多数人知晓的，经过分类编目的，代码设计经验的总结。<br>使用设计模式是为了重用代码，让代码更容易被他人理解，保证代码可靠性。  </p>
<a id="more"></a>

<h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h2><h3 id="1-0-创建型模式-Creational-Patterns"><a href="#1-0-创建型模式-Creational-Patterns" class="headerlink" title="1.0 创建型模式 (Creational Patterns)"></a>1.0 创建型模式 (Creational Patterns)</h3><p>这是设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用<code>new</code>运算符实例化对象。这使得程序在判断针对某个给定实例需要创建哪个对象时更加灵活。  </p>
<ul>
<li>工厂模式 (Factory Pattern)  </li>
<li>抽象工厂模式 (Abstract Factory Pattern)  </li>
<li>单例模式 (Singleton Pattern)  </li>
<li>建造者模式 (Builder Pattern)  </li>
<li>原型模式 (Prototype Pattern)  </li>
</ul>
<h3 id="1-1-结构性模式"><a href="#1-1-结构性模式" class="headerlink" title="1.1 结构性模式"></a>1.1 结构性模式</h3><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。  </p>
<ul>
<li>适配器模式 (Adapter Pattern)  </li>
<li>桥接模式 (Bridge Pattern)  </li>
<li>过滤器模式 (Filter, Criteria Pattern)  </li>
<li>组合模式 (Composite Pattern)  </li>
<li>装饰器模式 (Decorator Pattern)  </li>
<li>外观模式 (Facade Pattern)  </li>
<li>享元模式 (Flyweight Pattern)  </li>
<li>代理模式 (Proxy Pattern)  </li>
</ul>
<h3 id="1-2-行为型模式"><a href="#1-2-行为型模式" class="headerlink" title="1.2 行为型模式"></a>1.2 行为型模式</h3><p>这些设计模式特别关注对象之间的通信。  </p>
<ul>
<li>责任链模式 (Chain of Responsibility Pattern)  </li>
<li>命令模式 (Command Pattern)  </li>
<li>解释器模式 (Interpreter Pattern)  </li>
<li>迭代器模式 (Iterator Pattern)  </li>
<li>中介者模式 (Mediator Pattern)  </li>
<li>备忘录模式 (Memento Pattern)  </li>
<li>观察者模式 (Observer Pattern)  </li>
<li>状态模式 (State Pattern)  </li>
<li>空对象模式 (Null Object Pattern)  </li>
<li>策略模式 (Strategy Pattern)  </li>
<li>模板模式 (Template Pattern)  </li>
<li>访问者模式 (Visitor Pattern)  </li>
</ul>
<h3 id="1-3-J2EE模式"><a href="#1-3-J2EE模式" class="headerlink" title="1.3 J2EE模式"></a>1.3 J2EE模式</h3><p>这些设计模式特别关注表示层。  </p>
<ul>
<li>MVC 模式 (MVC Pattern)  </li>
<li>业务代表模式 (Business Delegate Pattern)  </li>
<li>组合实体模式 (Composite Entity Pattern)  </li>
<li>数据访问对象模式 (Data Access Object Pattern)  </li>
<li>前端控制器模式 (Front Controller Pattern)  </li>
<li>拦截过滤器模式 (Intercepting Filter Pattern)  </li>
<li>服务定位器模式 (Service Locator Pattern)  </li>
<li>传输对象模式 (Transfer Object Pattern)  </li>
</ul>
<h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2 原则"></a>2 原则</h2><h3 id="2-0-开闭原则-Open-Close-Principle"><a href="#2-0-开闭原则-Open-Close-Principle" class="headerlink" title="2.0 开闭原则 (Open Close Principle)"></a>2.0 开闭原则 (Open Close Principle)</h3><p>对<code>扩展开放，对修改关闭</code>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </p>
<h3 id="2-1-里氏代换原则-Liskov-Substitution-Principle"><a href="#2-1-里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="2.1 里氏代换原则 (Liskov Substitution Principle)"></a>2.1 里氏代换原则 (Liskov Substitution Principle)</h3><p>任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </p>
<h3 id="2-2-依赖倒转原则-Dependence-Inversion-Principle"><a href="#2-2-依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="2.2 依赖倒转原则 (Dependence Inversion Principle)"></a>2.2 依赖倒转原则 (Dependence Inversion Principle)</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </p>
<h3 id="2-3-接口隔离原则-Interface-Segregation-Principle"><a href="#2-3-接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="2.3 接口隔离原则 (Interface Segregation Principle)"></a>2.3 接口隔离原则 (Interface Segregation Principle)</h3><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </p>
<h3 id="2-4-迪米特法则，又称最少知道原则-Demeter-Principle"><a href="#2-4-迪米特法则，又称最少知道原则-Demeter-Principle" class="headerlink" title="2.4 迪米特法则，又称最少知道原则 (Demeter Principle)"></a>2.4 迪米特法则，又称最少知道原则 (Demeter Principle)</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。  </p>
<h3 id="2-5-合成复用原则-Composite-Reuse-Principle"><a href="#2-5-合成复用原则-Composite-Reuse-Principle" class="headerlink" title="2.5 合成复用原则 (Composite Reuse Principle)"></a>2.5 合成复用原则 (Composite Reuse Principle)</h3><p>尽量使用合成/聚合的方式，而不是使用继承。  </p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_单例模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-参考链接"><a href="#0-参考链接" class="headerlink" title="0 参考链接"></a>0 参考链接</h2><p><a href="https://www.bilibili.com/video/BV1Gz4y1d7RJ?from=search&seid=16674851411794252260" target="_blank" rel="noopener">链接_视频</a><br><a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">链接_文档</a>  </p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>单例模式，Singleton Pattern。  </p>
<a id="more"></a>  

<p><code>意图：</code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><code>主要解决：</code>一个全局使用的类频繁地创建与销毁。<br><code>何时使用：</code>需要控制实例数目，节省系统资源的时候。<br><code>如何解决：</code>判断系统是否已经有这个单例，如果有则返回，如果无则创建。<br><code>关键代码：</code>构造函数是私有的。<br><code>优点：</code>  </p>
<ul>
<li>在内存中只有一个实例，减少了内存开销，尤其是频繁的创建和销毁实例。  </li>
<li>避免对资源的多重占用。（比如写文件操作）  </li>
</ul>
<p><code>使用场景：</code>  </p>
<ul>
<li>要求生产唯一序列号。  </li>
<li>创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等。</li>
<li>日志类。  </li>
</ul>
<p><code>Highlight：</code></p>
<ul>
<li>单例类只能有一个实例。  </li>
<li>单例类必须自己创建自己的唯一实例。  </li>
<li>单例类必须给所有其他对象提供这一实例 <code>?</code>  </li>
<li>指针<code>*</code>存在线程安全问题，以下实现使用引用<code>&amp;</code>的方式。  </li>
</ul>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singletom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton() destruct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象的唯一的用户接口</span></span><br><span class="line">    <span class="comment">// static修饰符，使其与类无关</span></span><br><span class="line">    <span class="comment">// 返回引用&amp;，而不是指针*</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">CreateObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建static对象</span></span><br><span class="line">        <span class="keyword">static</span> Singletom obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// 使用delete，禁用拷贝构造</span></span><br><span class="line">    Singleton(Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// = 运算符重载</span></span><br><span class="line">    <span class="comment">// Singleton* operator= (Singleton&amp; obj) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="comment">// 构造函数私有化</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton() construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// 同时还要限制其拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数私有化</span></span><br><span class="line">    <span class="comment">// Singleton(Singleton&amp; obj) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; "Singleton(Singleton&amp; obj) construct" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用引用来接函数返回值</span></span><br><span class="line">    <span class="comment">// 因为方法是static，所以使用 类名::函数名 方式调用</span></span><br><span class="line">    <span class="comment">// pObj1和pObj2是同一个实例（同一块内存）</span></span><br><span class="line">    Singletom&amp; pObj1 = Singletom::CreateObject();</span><br><span class="line">    Singletom&amp; pObj2 = Singletom::CreateObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200627</title>
    <url>/2020/06/27/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200627/</url>
    <content><![CDATA[<p>六月的上海是淅淅沥沥不停的雨天，为这偌大的城市增添几分烟雨朦胧的隐秘感。  </p>
<p>端午节小假期就要结束了，自然醒洗漱后的上午，打开窗户，呼吸着湿润的新鲜空气，隔着耳机听着滴答的雨声。安静下来，整理下近些日子的心情吧。<br>如同往常，心中能有希望坐下来记录些什么的冲动，必定是因为丧到了一定程度。所以接下来的内容必定会略显消极悲观，但却是对生活的真实认知与感受。<br><code>请选择性阅读，不接受指点评论。</code>  </p>
<a id="more"></a>  

<p>从老妈生病开始吧。为什么生活总是选择欺负最善良无助的人？和大多数农村家庭主妇一样，老妈没有念过大学，没有过人的天资，没有很高的远见，没有科学的教育培养孩子的方法。但她是如此的勤勤恳恳，任劳任怨，朴素节俭，这些词都太过于轻描淡写不足以形容。世上的甘甜有七分，您却只尝了三分；世上的苦难有三分，您缺尝了七分。老姐好心带老妈去医院体检身体，查找常年低质量睡眠的病因，大夫开了中药帮助调理身体，可万万没想到中药却引起了更加严重的急性肝损伤，并导致黄疸。老妈病黄消瘦的面庞，异常高的吓人的血常规指标，无一不使人担忧至极。<br>生活又放过了谁呢，每个人不都正在经历苦难吗？有人因为连续的考研失败而变得抑郁，有人还在因为没有小论文无法按期拿到毕业和学位证而苦恼，有人已经毕业了却还未能拿到相对满意的工作offer，有人失去了亲人生活崩塌性破碎…。幸福的人总是相似的，不幸的人各有各的不幸。生活本是如此，不如意十有八九。等它们都过去了，就变成了一个个故事。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200510</title>
    <url>/2020/05/10/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200510/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>丢掉学生的标签成为社会人已经有一段时间了，入职了校招时曾经引以为豪的商汤科技。既然使用<code>曾经</code>来形容，便意味着这些日子并不是十分如意。  </p>
  <a id="more"></a>  

<p>直到如今，关于职业与理想也并没有很清晰的规划。大四专业实习在武汉做外业测量，工作内容是施工基坑和周围建筑物的沉降变形监测，化身为名副其实的跑杆神童，如果非要总结实习收获，便只能是掌握了各种扶尺姿势，这种和专科生混在一起的工作怎么能对得起自命不凡的性格。获得保研资格后，甚至还曾为武大老师开出的<code>10W+</code>的年薪动摇读研的想法，公司做三维扫描仪研发，相比于外业测量工作已提升了一个Level，无论如何，现在看来当时的抉择也是正确的。选择导师时，由于夏令营成绩排名靠后，而被林老师推给叶老师，专业从遥感转为摄影测量，在入学后，又误打误撞地入了<code>SLAM</code>的坑，算是半脚踏入了互联网行业。受助于春红的内推，有幸能够去<code>Momenta</code>实习，并遇到了如此Nice的Mentor海瑞，提升了自身能力，认识了<code>自动驾驶</code>。相对可观的薪资，公司的工作研发氛围，和在校期间不开心等因素混杂在一起，成了继续求学道路上的巨大阻碍，并最终放弃了读博的梦想。人生的轨迹被无数的随机和选择排列组合着，没有明确的通行指示标志，反倒是像一张密密麻麻的由数不清的立交，隧道、匝口编织成的迷魂阵。  </p>
<p>入职前被告知被安排到系统组，而不是本该的地图定位组，Title从算法研发工程师转为系统开发工程师，入职后更是发现做的工作连自动驾驶都谈不上，而是<code>ADAS</code>相关，这和心心念的<code>定位算法研发</code>产生巨大落差，同时带来的是无数的思考与质问。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily Work</title>
    <url>/2020/05/07/daily_work/daily_work/</url>
    <content><![CDATA[<blockquote>
<p>工作学习生活记录  </p>
</blockquote>
<h1 id="2020-05-08"><a href="#2020-05-08" class="headerlink" title="2020.05.08"></a>2020.05.08</h1><h2 id="1-Markdown教程"><a href="#1-Markdown教程" class="headerlink" title="1 Markdown教程"></a>1 Markdown教程</h2><p>为了使这份Daily Work记录文档更加优美实用，Markdown语法<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">教程</a>呈上！  </p>
<h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><p>使用<code>=</code>和<code>-</code>标记一级和二级标题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>
<p>使用<code>#</code>标记1-6级标题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<h3 id="1-2-段落格式"><a href="#1-2-段落格式" class="headerlink" title="1.2 段落格式"></a>1.2 段落格式</h3><h4 id="1-2-1-段落"><a href="#1-2-1-段落" class="headerlink" title="1.2.1 段落"></a>1.2.1 段落</h4><p>段落换行可以使用两个空格+回车，也可以使用一个空行。  </p>
<h4 id="1-2-2-字体"><a href="#1-2-2-字体" class="headerlink" title="1.2.2 字体"></a>1.2.2 字体</h4><p>特殊字体包括斜体、粗体和粗斜体三种。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-分割线"><a href="#1-2-3-分割线" class="headerlink" title="1.2.3 分割线"></a>1.2.3 分割线</h4><p>使用三个以上的<code>*</code>或<code>-</code>，建立分割线，行内不能有其他东西。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-删除线"><a href="#1-2-4-删除线" class="headerlink" title="1.2.4 删除线"></a>1.2.4 删除线</h4><p>在文本的两端加上两个<code>~~</code>，实现在文本上添加删除线。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~文本~~</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-下划线"><a href="#1-2-5-下划线" class="headerlink" title="1.2.5 下划线"></a>1.2.5 下划线</h4><p>在文本的两端加上<code>&lt;/u&gt;</code>，实现在文本下方添加下划线。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;u&gt;文本&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-脚注"><a href="#1-2-6-脚注" class="headerlink" title="1.2.6 脚注"></a>1.2.6 脚注</h4><p>使用<code>[^脚注]</code>的方式为文本添加脚注，注意脚注标示的一致对应。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本[^脚注1]</span><br><span class="line">[^脚注1]: 脚注内容</span><br></pre></td></tr></table></figure>
<h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>无序列表使用<code>*</code>或<code>+</code>或<code>-</code>标记，有序列表使用<code>数字.</code>标记。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line"></span><br><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure>
<h3 id="1-4-区块"><a href="#1-4-区块" class="headerlink" title="1.4 区块"></a>1.4 区块</h3><p>引用是在段落开头使用<code>&gt;</code>标记。区块是可以嵌套的，一个<code>&gt;</code>是最外层，两个<code>&gt;&gt;</code>是第一层嵌套，以此类推。此外，区块和列表可相互嵌套，自由发挥。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure>
<h3 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5 代码"></a>1.5 代码</h3><p>函数可以使用反引号<code>``</code>包括。单独的代码段可以使用<code>``` bash</code>包括，语言根据实际情况更换，添加语言标示，能够自动地更加美观的颜色显示代码。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;函数&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line">代码段</span><br><span class="line">&#96;&#96;&#96;                                                                  .</span><br></pre></td></tr></table></figure>
<h3 id="1-6-链接"><a href="#1-6-链接" class="headerlink" title="1.6 链接"></a>1.6 链接</h3><p>根据是否显式地显示网址，可以有两种添加链接的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-图片"><a href="#1-7-图片" class="headerlink" title="1.7 图片"></a>1.7 图片</h3><p>图片地址可以是网址，也可以是目录路径。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>
<p>Markdown无法制定图片的高度与宽度，如有需要，可使用普通的<code>&lt;img&gt;</code>标签。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;图片地址&quot; width&#x3D;&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-表格"><a href="#1-8-表格" class="headerlink" title="1.8 表格"></a>1.8 表格</h3><p>制作表格使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头与其他行。<code>:-</code>左对齐，<code>-:</code>右对齐，<code>:-:</code>居中对齐。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>


<h2 id="2-NFS配置与使用"><a href="#2-NFS配置与使用" class="headerlink" title="2 NFS配置与使用"></a>2 <code>NFS</code>配置与使用</h2><p><code>NFS</code>服务中需要有两台机器，一台作为<code>NFS Serve</code>，另一台作为<code>NFS Client</code>。参考<a href="https://blog.csdn.net/zpf336/article/details/50825847" target="_blank" rel="noopener">链接</a>。  </p>
<h3 id="2-1-NFS-Serve"><a href="#2-1-NFS-Serve" class="headerlink" title="2.1 NFS Serve"></a>2.1 <code>NFS Serve</code></h3><p>安装<code>nfs-server</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y nfs-server</span><br></pre></td></tr></table></figure>
<p>创建将被分享的文件夹，即被<code>NFS Client</code> mount的文件夹。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/liuhang/share</span><br></pre></td></tr></table></figure>
<p>配置<code>NFS Serve</code>，修改<code>/etc/exports</code>文件，在最后一行添加：<code>/home/liuhang/share ${ip}(rw, sync, no_root_squash)</code>，其中<code>${ip}</code>是指能够访问该共享文件夹的<code>NFS Client</code>的ip。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure>
<p>启动<code>NFS</code>服务。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nfs-server start</span><br><span class="line">sudo service nfs-server restart</span><br></pre></td></tr></table></figure>
<h3 id="2-2-NFS-Client"><a href="#2-2-NFS-Client" class="headerlink" title="2.2 NFS Client"></a>2.2 <code>NFS Client</code></h3><p>安装<code>nfs-common</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure>
<p>在<code>NFS Client</code>本地目录中创建新文件夹，并挂载<code>NFS Server</code>的共享文件夹。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ./new_folder/</span><br><span class="line">chmod -R 777 ./new_folder/</span><br><span class="line">mount -o nolock -t nfs <span class="variable">$&#123;NFS Server ip&#125;</span>:/home/liuhang/share ./new_folder</span><br></pre></td></tr></table></figure>
<p>至此即可以在<code>NFS Client</code>访问<code>NFS Server</code>的共享文件夹，进行文件的读写。  </p>
<h1 id="2020-05-09"><a href="#2020-05-09" class="headerlink" title="2020.05.09"></a>2020.05.09</h1><h2 id="1-Amba平台JDK与JNLP安装"><a href="#1-Amba平台JDK与JNLP安装" class="headerlink" title="1 Amba平台JDK与JNLP安装"></a>1 Amba平台JDK与JNLP安装</h2><p><a href="https://blog.csdn.net/u012417380/article/details/72809590" target="_blank" rel="noopener">Ubuntu下JDK的安装与环境配置</a><br><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">JDK下载</a><br><a href="https://www.cnblogs.com/tiandi/p/11317083.html" target="_blank" rel="noopener">Linux中环境变量和系统加载环境变量的顺序</a>  </p>
<h2 id="2-Jenkins环境配置"><a href="#2-Jenkins环境配置" class="headerlink" title="2 Jenkins环境配置"></a>2 Jenkins环境配置</h2><p><a href="https://zhuanlan.zhihu.com/p/79027031" target="_blank" rel="noopener">Jenkins环境配置篇–增加节点</a><br><a href="http://www.mamicode.com/info-detail-2395829.html" target="_blank" rel="noopener">Jenkins构建多节点之Linux节点</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>SVN服务器搭建与使用</title>
    <url>/2020/05/02/%E6%95%99%E7%A8%8B/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>SVN(subversion)是一个开放源代码的版本控制系统  </p>
</blockquote>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="1-安装-svn"><a href="#1-安装-svn" class="headerlink" title="1 安装 svn"></a>1 安装 svn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install subversion</span><br></pre></td></tr></table></figure>

<h3 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2 创建仓库"></a>2 创建仓库</h3><p>在指定的文件夹下创建新的仓库(repository)。 如在 <code>/data/svn</code> 文件夹下创建名为 <code>repo</code> 的仓库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /data/svn</span><br><span class="line">$ mkdir repo</span><br><span class="line">$ svnadmin create /data/svn/repo</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<p>创建完成后，在 <code>/data/svn/repo</code> 文件夹中会有相关文件：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ll ./repo</span><br><span class="line">total 32</span><br><span class="line">drwxrwxr-x 6 ** ** 4096 4月  26 09:50 ./</span><br><span class="line">drwxr-xr-x 5 ** ** 4096 4月  26 09:50 ../</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 conf/</span><br><span class="line">drwxrwsr-x 6 ** ** 4096 4月  26 09:50 db/</span><br><span class="line">-r--r--r-- 1 ** **    2 4月  26 09:50 format</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 hooks/</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 locks/</span><br><span class="line">-rw-rw-r-- 1 ** **  246 4月  26 09:50 README.txt</span><br></pre></td></tr></table></figure>

<h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3 修改配置"></a>3 修改配置</h3><p>在生成的文件中，<code>conf</code> 文件夹是用来存放配置文件的，其中 <code>passwd</code> 是账号密码文件，<code>authz</code> 是权限控制文件，<code>svnserve.conf</code>是svn服务配置文件。  </p>
<h4 id="3-1-配置-passwd"><a href="#3-1-配置-passwd" class="headerlink" title="3.1 配置 passwd"></a>3.1 配置 <code>passwd</code></h4><p>添加新用户与密码。如 <code>leo = 123789</code>，创建了用户 <code>leo</code>，密码为 <code>123789</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line"><span class="comment"># harry = harryssecret</span></span><br><span class="line"><span class="comment"># sally = sallyssecret</span></span><br><span class="line"></span><br><span class="line">leo = 123789</span><br></pre></td></tr></table></figure>
<h4 id="3-2-配置-authz"><a href="#3-2-配置-authz" class="headerlink" title="3.2 配置 authz"></a>3.2 配置 <code>authz</code></h4><p>为新加的用户添加文件读写权限，<code>r</code> 表示读权限，<code>w</code> 表示写权限，<code>rw</code>表示读写权限，此处添加的读写权限包括仓库 <code>/data/svn/repo/</code> 中的所有文件，。如 <code>leo = rw</code> 表示为用户 <code>leo</code> 添加读写权限，<code>* =</code> 表示其他用户无任何权限，注意前置符 <code>[/]</code> 不可省略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[/]</span><br><span class="line">leo = rw</span><br><span class="line">* =</span><br></pre></td></tr></table></figure>
<p>如果需要对用户进行分组批量管理权限，可以使用 <code>[groups]</code> 标签。如下配置中创建了 <code>groups1</code> 和 <code>groups2</code>分组，并为两个分组设置不同的权限，注意组内的多个用户使用 <code>,</code> 隔开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[groups]</span><br><span class="line">groups1 = leo, john</span><br><span class="line">groups2 = lily</span><br><span class="line">[/]</span><br><span class="line">@groups1 = rw</span><br><span class="line">@groups2 = r</span><br><span class="line">* =</span><br></pre></td></tr></table></figure>
<h4 id="3-3-配置-svnserve-conf"><a href="#3-3-配置-svnserve-conf" class="headerlink" title="3.3 配置 svnserve.conf"></a>3.3 配置 <code>svnserve.conf</code></h4><p>打开以下4个注释，注意打开注释时前面不要留有空格，否则访问库会报错。注意 <code>anon-access</code> 需改为 <code>none</code>, 否则 <code>svn log</code> 无法使用，why ?!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anon-access = none   <span class="comment"># 匿名用户无权限</span></span><br><span class="line">auth-access = write   <span class="comment"># 授权用户可写</span></span><br><span class="line">password-db = passwd   <span class="comment"># 指定账号文件</span></span><br><span class="line">authz-db = authz   <span class="comment"># 指定权限文件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4 启动服务"></a>4 启动服务</h3><p>配置完成后，可启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svnserve -d -r /data/svn/</span><br></pre></td></tr></table></figure>
<p>其中 <code>-d</code> 表示已守护模式启动，<code>-r</code> 表示指定svn版本库的根目录，便于客户端不用输入全路径就可以访问版本库。服务器默认使用 <code>3690</code> 端口号，若要使用非默认端口，可在启动命令后加 <code>--listen-port ××××</code>， 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ svnserve -d -r &#x2F;data&#x2F;svn&#x2F; --listen-port 3691</span><br></pre></td></tr></table></figure>
<p>启动后，可检查是否启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep svnserve</span><br><span class="line">senseti+ 12899  0.0  0.0  80556   948 ?        Ss   10:54   0:00 svnserve -d -r /data/svn</span><br><span class="line">senseti+ 12903  0.0  0.0  21292   984 pts/2    S+   10:55   0:00 grep --color=auto svnserve</span><br></pre></td></tr></table></figure>

<h3 id="5-关闭服务"><a href="#5-关闭服务" class="headerlink" title="5 关闭服务"></a>5 关闭服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ killall svnserve</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="1-安装-svn-1"><a href="#1-安装-svn-1" class="headerlink" title="1 安装 svn"></a>1 安装 svn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install subversion</span><br></pre></td></tr></table></figure>

<h3 id="2-提取操作"><a href="#2-提取操作" class="headerlink" title="2 提取操作"></a>2 提取操作</h3><p>在服务器启动服务后，可在客户端提取版本库文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn checkout svn://服务器ip/仓库名</span><br></pre></td></tr></table></figure>
<p>在执行提取命令后，将提示输入用户名和密码信息，提取的仓库文件保存在当前文件目录下。</p>
<h3 id="3-提交操作"><a href="#3-提交操作" class="headerlink" title="3 提交操作"></a>3 提交操作</h3><p>在提取版本库中增添或修改新的文件后，可提交至服务器版本库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn add 新增文件</span><br><span class="line">$ svn commit -m <span class="string">"提交信息"</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>commit</code> 命令后可跟文件名，仅提交指定的文件。</p>
<h3 id="4-提示！！"><a href="#4-提示！！" class="headerlink" title="4 提示！！"></a>4 提示！！</h3><p>对于新建的仓库，为了规范仓库管理，建立checkout到本地副本后，在仓库中创建 <code>trunk</code>, <code>branches</code> 和 <code>tags</code>三个文件夹，其中 <code>trunk</code> 存放主分支，<code>branches</code> 存放开发分支，<code>tags</code> 存放标签。  </p>
<hr>
<h2 id="更多常用命令"><a href="#更多常用命令" class="headerlink" title="更多常用命令"></a>更多常用命令</h2><h3 id="1-帮助"><a href="#1-帮助" class="headerlink" title="1 帮助"></a>1 帮助</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn <span class="built_in">help</span>   <span class="comment"># 查看svn所有子命令(subcommands)</span></span><br><span class="line">$ svn <span class="built_in">help</span> &lt;subcommands&gt;   <span class="comment"># 查看某个子命令的使用方法</span></span><br></pre></td></tr></table></figure>

<h3 id="2-添加文件到版本控制"><a href="#2-添加文件到版本控制" class="headerlink" title="2 添加文件到版本控制"></a>2 添加文件到版本控制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn add 文件名   <span class="comment"># 添加一个文件</span></span><br><span class="line">$ svn add 文件夹名   <span class="comment"># 添加一个文件夹中所有未添加的文件</span></span><br><span class="line">$ svn add 文件夹名 --non-recursive   <span class="comment"># 仅添加本文件夹，不添加文件夹中的内容</span></span><br><span class="line">$ svn add *   <span class="comment"># 添加s所有的文件(文件夹已经添加进去的不在进行操作)</span></span><br><span class="line">$ svn add * --force   <span class="comment"># 添加所有的文件(文件夹已经添加进去的也要再进行操作)</span></span><br><span class="line">$ svn add . --no-ignore --force   <span class="comment"># 添加当前目录下所有未添加的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="3-查看信息"><a href="#3-查看信息" class="headerlink" title="3 查看信息"></a>3 查看信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn status    <span class="comment"># 查看文件修改</span></span><br><span class="line">$ svn <span class="built_in">log</span> -r 2:3   <span class="comment"># 查看版本2和3之间的信息(版本作者、日期、路径等)</span></span><br><span class="line">$ svn <span class="built_in">log</span> 文件名   <span class="comment"># 查看某个文件的版本修改信息</span></span><br><span class="line">$ svn <span class="built_in">log</span> -l N -v   <span class="comment"># 查看限定N条记录的目录信息</span></span><br><span class="line">$ svn diff   <span class="comment"># 比较工作文件与缓存在.svn的原始拷贝</span></span><br><span class="line">$ svn diff -r 3 文件名   <span class="comment"># 比较工作拷贝和版本库中版本号为3的文件</span></span><br><span class="line">$ svn diff -r 2:3 文件名   <span class="comment"># 比较版本2和3的文件</span></span><br><span class="line">$ svn cat -r 版本号 文件名   <span class="comment"># 查看该版本号下该文件的内容</span></span><br><span class="line">$ svn list svn://服务器ip/版本库名   <span class="comment"># 在不下载文件到本地目录的情况下查看目录中的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-分支使用"><a href="#4-分支使用" class="headerlink" title="4 分支使用"></a>4 分支使用</h3><p>将trunk主分支内容copy至新建分支my_branch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn copy trunk/ branches/my_branch</span><br></pre></td></tr></table></figure>
<p>切换到新建分支进行开发，开发完成后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commit -m <span class="string">"update my_branch"</span></span><br></pre></td></tr></table></figure>
<p>切换至trunck分支，进行分支合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn update</span><br><span class="line">$ svn merge ../branches/my_branch</span><br></pre></td></tr></table></figure>
<p>把合并好后的trunk提交到版本库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commmit -m <span class="string">"update trunk"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-标签使用"><a href="#5-标签使用" class="headerlink" title="5 标签使用"></a>5 标签使用</h3><p>在本地工作副本中创建一个tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn copy trunk/ tags/v1.0</span><br></pre></td></tr></table></figure>
<p>提交tag内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commit -m <span class="string">"tag v1.0"</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/svn/svn-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/svn/svn-tutorial.html</a>  </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200405</title>
    <url>/2020/04/05/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200405/</url>
    <content><![CDATA[<blockquote>
<p>青春逢盛世，奋斗正当时——做爱国主义的坚定弘扬者和践行者  </p>
</blockquote>
<p>春暖花开，疫情的阴霾终将渐渐散开。陈校长以《青春逢盛世，奋斗正当时——做爱国主义的坚定弘扬者和践行者》为主题，通过在线的方式为全校师生上了一堂精彩的思政大课。  </p>
<p><img src="../../../../../files/%E9%9A%8F%E7%AC%94/%E6%80%9D%E6%94%BF%E8%AF%BE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/p1.jpg" alt="听课现场" title="听课现场">  </p>
<a id="more"></a>  

<p>祖国，我们强大的后盾。党中央立足疫情防控的严峻形势，站在统揽全国疫情防控工作和保障人民群众生命安全的高度，作出了应对新冠病毒疫情的重大决策部署，吹响了坚决打赢疫情防控阻击战的冲锋号。中国特色社会主义制度的优越性在于坚持党的领导，在于集中力量办大事，在于始终坚持以人民群众为中心。打赢新冠病毒疫情防控阻击战，就要充分发挥社会主义制度的优越性。  </p>
<p>青春，越是艰险越向前。在新冠疫情防控斗争中，青年人同在一线英勇奋战的广大疫情防空人员一道，不畏艰险，冲锋在前，舍生忘死，彰显了青春的蓬勃力量，交出了合格答卷，广大青年用行动证明，新时代的中国青年是好样的，是堪当大任的。  </p>
<p>爱国，同济人这样传承。同济人与中华民族命运与共，伟大复兴绝不是轻轻松松，敲锣打鼓就能实现的，无数同济人发扬斗争精神，以坚忍不拔的意志和无私无畏的勇气，战胜前进道路上的一切艰难险阻。浓厚的家国情怀和强烈的社会责任感，代代相传，这种爱国精神传承的不仅是知识和文脉，还是一所大学的精神与责任，更是不忘初心牢记使命的写照。  </p>
<p>践行，让青春绽放光彩。同济人乃栋梁之才，擎天之柱，头顶苍穹，脚踏实地，锤炼自身，心怀爱国之志，砥砺报国之行。作为一名即将踏上工作岗位的研究生，要继续在为人民服务中茁壮成长，在艰苦奋斗中砥砺意志品质，在实践中增长工作本领，让青春在党和人民最需要的地方绽放绚丽之花。  </p>
<p>大时代的破局者，注定波澜壮阔。在最好的时代，做一个了不起的梦。  </p>
<p><a href="https://news.tongji.edu.cn/info/1002/73253.htm?from=singlemessage&isappinstalled=0" target="_blank" rel="noopener">链接1</a> <a href="https://mp.weixin.qq.com/s/BDhwYZ70znbtsXZ1ASaz2w" target="_blank" rel="noopener">链接2</a> <a href="https://mp.weixin.qq.com/s/t35x48rMIzRqWss5yj6Enw" target="_blank" rel="noopener">链接3</a> <a href="https://weibointl.api.weibo.cn/share/137409194.html?weibo_id=4488987966322149" target="_blank" rel="noopener">链接4</a>  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>思政</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200404</title>
    <url>/2020/04/04/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200404/</url>
    <content><![CDATA[<p>老家确实不适合长期居住，眼界和心思都跟着变得封闭狭窄，情绪会轻易地受到鸡毛蒜皮邻里间琐碎小事的影响，成了地地道道的小肚鸡肠鼠目寸光的乡下人，这与自命不凡的心中大志是完全相悖的。  </p>
<a id="more"></a>  

<p>原本听起来像是玩笑话的五月份开学也将要变成了现实，三个月余超长寒假消磨着千万学生的意志。事情大致按照预想的方向发展着，在3月20号前通过网络视频会议的方式完成了毕业论文答辩，在严峻疫情的当下依然赶上了往届的进度。在激烈的竞争中也最终拿到了名额有限的上海市优秀毕业生荣誉称号，为学生时代的结束画上完美的句号。申请上海市户籍的积分已累积82分，不需要再为之担心顾虑。  </p>
<p>刚进入同济时，虽是保研但却是倒数第一，与同济本校的同学相比更是实力相差悬殊，对天赋禀异的他们心生敬畏，当然与之并存的是自卑胆怯弱小无助和低人一等。如今已要和这里道别，也终于混出了不比别人差的模样。科研成果，荣誉称号，实习经历和工作签约，都有些许拿得出手得意洋洋的资本。多像是，岁月特别实在，你想要的终会到来。  </p>
<p>连续多日的颓废累计了大批量的愧疚感，科研和Coding能力已接近丧失。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>DS-SLAM</title>
    <url>/2020/03/08/PaperReading/DS-SLAM/</url>
    <content><![CDATA[<blockquote>
<p> A Semantic Visual SLAM towards Dynamic Environments  </p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>SLAM系统在动态场景中易受到动态物体的干扰，且创建的地图仅包含几何信息，如路标点地图或点云地图，无法用于高级别的场景理解。  </p>
<p>DS-SLAM结合图像予以分割网络和运动一致性检测，消减场景中动态障碍物的影响，提高定位精度。同时，创建稠密的语义八叉树地图，满足机器人高级别的任务。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p1.png" alt="Overview" title="Overview">  </p>
<a id="more"></a>  

<h2 id="2-Methods"><a href="#2-Methods" class="headerlink" title="2 Methods"></a>2 Methods</h2><h3 id="2-1-Framework"><a href="#2-1-Framework" class="headerlink" title="2.1 Framework"></a>2.1 Framework</h3><p>DS-SLAM在ORB-SLAM2的基础上拓展，系统包含5个并行线程：特征追踪，局部建图，回环检测，稠密语义建图。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p2.png" alt="Framework" title="Framework">  </p>
<h3 id="2-2-Semantic-Segmentation"><a href="#2-2-Semantic-Segmentation" class="headerlink" title="2.2 Semantic Segmentation"></a>2.2 Semantic Segmentation</h3><p>使用SegNet对彩图图像进行语义分割，并仅把行人作为潜在动态物体。  </p>
<h3 id="2-3-Moving-Consistency-Check"><a href="#2-3-Moving-Consistency-Check" class="headerlink" title="2.3 Moving Consistency Check"></a>2.3 Moving Consistency Check</h3><p>根据光流信息查找特征点中是运动的点，具体实现细节不太理解。  </p>
<p>之所以这么做是因为不完全相信语义分割的结果，其对于静止的人身上的特征点是选择保留的。并解释说，语义分割的线程较慢，特征追踪的线程较快，闲着也是闲着，所以增加了这个运动一致性检测的模块。WF??!!  </p>
<h3 id="2-4-Outliers-Rejection"><a href="#2-4-Outliers-Rejection" class="headerlink" title="2.4 Outliers Rejection"></a>2.4 Outliers Rejection</h3><p>结合运动一致性和语义分割信息，仅剔除正在运动的行人身上的特征点对。  </p>
<h3 id="2-5-Dense-Semantic-3D-Octo-tree-Map-Building"><a href="#2-5-Dense-Semantic-3D-Octo-tree-Map-Building" class="headerlink" title="2.5 Dense Semantic 3D Octo-tree Map Building"></a>2.5 Dense Semantic 3D Octo-tree Map Building</h3><p>八叉树地图灵活，紧凑，可更新，存储效率高，便于导航。  </p>
<p>Voxel的语义属性采用概率表达，便于更新。  </p>
<p>由于语义分割的精度有限，且在复杂场景中物体相互遮挡，导致语义分割的结果存在错误。Voxel的存在性使用log-odds值计算更新。  </p>
<h2 id="3-Results"><a href="#3-Results" class="headerlink" title="3 Results"></a>3 Results</h2><p>使用TUM数据集和自采数据进行测试。  </p>
<p>一帧耗时59.4ms，既然是多线程并行，耗时就不应该是各线程耗时和。  </p>
<p>在动态场景中，相比于ORB-SLAM2，定位精度大幅提升。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p3.png" alt="ORB-SLAM2" title="ORB-SLAM2"><br><img src="../../../../../files/PaperReading/DS_SLAM/p4.png" alt="DS-SLAM" title="DS-SLAM">  </p>
<h2 id="4-Ponder"><a href="#4-Ponder" class="headerlink" title="4 Ponder"></a>4 Ponder</h2><p>a) 运动一致性检测的实现细节?<br>b) Voxel语义属性概率表达如何实现?<br>c) Voxel存在性怎么使用log-odds更新?  </p>
<h2 id="5-More"><a href="#5-More" class="headerlink" title="5 More"></a>5 More</h2><p>Paper：<a href="../../../../../files/PaperReading/DS_SLAM/DS-SLAM_A_Semantic_Visual_SLAM_towards_Dynamic_Environments.pdf">链接</a>  </p>
]]></content>
      <categories>
        <category>PaperReading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>RGB-D</tag>
        <tag>Semantic</tag>
      </tags>
  </entry>
  <entry>
    <title>Loam-livox</title>
    <url>/2020/03/02/PaperReading/Loam-livox/</url>
    <content><![CDATA[<blockquote>
<p>A fast robust high-precision LiDAR odometry and mapping package for LiDARs of small FoV  </p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>相比于传统的机械旋转式Lidar, mems振镜固态式Lidar价格相对低廉, 为Lidar的大规模拓展应用提供更多可能性，成为一大风口.  </p>
<p>固态Lidar特点：<br>1 Small FoV：小视角特征较少易出现退化现象，且易受到动态物体的影响<br>2 Irregular scanning pattern：不规则扫描不利于特征提取, 无法直观有效地获取点间的近邻关系<br>3 Non-repetitive scanning：即使Lidar处于静止状态, 相邻两帧点云也是不同的<br>4 Motion blur：同旋转式Lidar, 连续扫描使得帧内数据获取时间不严格一致  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p4.png" alt="扫描方式" title="扫描方式">  </p>
<p>本文在LOAM的基础上进行拓展，研究内容包括特征提取, 运动补偿, 误关联剔除, 动态物体剔除  </p>
<a id="more"></a>  

<h2 id="2-Methods"><a href="#2-Methods" class="headerlink" title="2 Methods"></a>2 Methods</h2><h3 id="2-1-Points-selection-and-feature-extraction"><a href="#2-1-Points-selection-and-feature-extraction" class="headerlink" title="2.1 Points selection and feature extraction"></a>2.1 Points selection and feature extraction</h3><p>在进行特征提取前, 先筛选剔除以下几类点：视场边缘的点, 反射强度过大或过小的点, 与局部平面夹角近似0°或180°的点 (这里的局部平面怎么得到的呢?), 被遮挡的点 (怎么优雅地遍历呢?).  </p>
<p>特征提取的方法延用LOAM (不规则的扫描方式, 怎么查找点间的近邻关系呢?), 同时考虑反射强度信息, 与近邻点的强度值差别较大的点亦定义为角点.  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p6.png" alt="特征提取与数据关联" title="特征提取与数据关联">  </p>
<h3 id="2-2-Iterative-pose-optimization"><a href="#2-2-Iterative-pose-optimization" class="headerlink" title="2.2 Iterative pose optimization"></a>2.2 Iterative pose optimization</h3><p>延用LOAM中点到线和点到面的数据关联方式. 论文中使用的edge-to-edge和plane-to-plane的说法是不严谨的.  </p>
<p>运动补偿的方法包括piecewise processing和linear interpolation两种. 其中piecewise processing是指将一帧点云按照扫描顺序分为三个sub-frames, 分别独立地对三个sub-frames进行帧与地图的匹配, sub-frames的匹配在并行的三个线程中独立处理 (值得借鉴), 并且试验中证明这种运动补偿的方式更优.  </p>
<p>误匹配和动态物体的剔除在优化求解中统一处理. 迭代优化求解时，在迭代两遍后，然后剔除误差较大的20%的关联，然后再接着迭代优化 (机智啊!).  </p>
<h2 id="3-Results"><a href="#3-Results" class="headerlink" title="3 Results"></a>3 Results</h2><p>建的图好看就完事了~<br><img src="../../../../../files/PaperReading/Loam_livox/p1.png" alt="SLAM_1" title="SLAM_1">  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p2.png" alt="SLAM_2" title="SLAM_2">  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p8.png" alt="SLAM_3" title="SLAM_8">  </p>
<h2 id="4-Ponder"><a href="#4-Ponder" class="headerlink" title="4 Ponder"></a>4 Ponder</h2><p>a) 特征提取模块的代码实现细节?<br>b) Piecewise processing中三个独立的子线程如何实现?<br>c) 误匹配和动态物体的剔除技巧值得借鉴呀!  </p>
<h2 id="5-More"><a href="#5-More" class="headerlink" title="5 More"></a>5 More</h2><p>Paper：<a href="../../../../../files/PaperReading/Loam_livox/Loam-livox_A_fast_robust_high-precision_LiDAR_odometry_and_mapping_package_for_LiDARs_of_small_FoV.pdf">链接</a><br>Code：<a href="https://github.com/hku-mars/loam_livox" target="_blank" rel="noopener">链接</a><br>Sensor：<a href="https://www.livoxtech.com/mid-40-and-mid-100" target="_blank" rel="noopener">连接</a></p>
]]></content>
      <categories>
        <category>PaperReading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Lidar</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200216</title>
    <url>/2020/02/16/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200216/</url>
    <content><![CDATA[<blockquote>
<p>在最好的时代，做一个了不起的梦。  </p>
</blockquote>
<p>计划总是被变化甩上几条街的距离。突如其来的疫情扰乱着14亿人的计划。工厂的设备停止运转，工人隔离在家中等待着政府的号令; 学校的教室空空如也，学生以观看直播的方式响应着”停课不停学”的计划; 医院的病房人满为患，医护人员和感染病人争分夺秒地与病毒抗争着。巨大的社会机器像是一列的<a href="https://movie.douban.com/subject/3071441/" target="_blank" rel="noopener">雪国列车</a>，灾难、恐慌、权力、等级、人性等。  </p>
<a id="more"></a>  

<p>最后一个学生时代的假期竟是如此特殊，多次延期使其变得极其漫长。原定于三月份的毕业答辩变得遥遥无期，在诗情画意的樱花大道拍张毕业照定格学生时代的梦想也变为不可能，毕业论文致谢中预言的”冬去春来，已有朵朵早樱点缀着樱花大道，呼唤着樱花盛开的到来，为毕业季增添几分美好与诗意”成了一纸空话。  </p>
<p>可以预想，在一个匆匆的简易毕业典礼后，就要彻底和校园说再见了。或许是20余年的习惯，或许是对安逸生活的依赖，或许是未能满足的自尊心，使得这份别离夹杂着如此多的酸楚。 </p>
<p>身边的很多同事和同学有着博士学历或选择继续攻读博士学位，而自己却就要止步于一名小硕士，如同低人一等的矮个子，和他们交谈时不得不被俯视。曾经为录用Offer薪资的沾沾自喜感已灰飞烟灭，从此之后，优秀等字眼可能将会越走越远，成为一名普普通通的人。  </p>
<p>学习的目的是什么呢？增加技能与提升价值。  </p>
<p>学历和能力的竞争力哪个更胜一筹呢？旗鼓相当。  </p>
<p>深造和就业怎么选择呢？深造，学历和能力是可以兼得的; 就业，当且仅当能力的提升速度是前者的倍数，二者才可相提并论。  </p>
<p>从近一年的实习经历来看，”倍数”的假设是能够成立的。在公司实习的日子是整个研究生阶段最快乐的时光，相比于教研室苦闷、忧愁、焦虑、无作为的生活节奏，在公司研发的感受更多是充实、积极、拼搏、成就。  </p>
<p>既然没有圣人指明前行道路，评判每个选择的正确性，便只能跟随内心凭借直觉摸着石头过河。幻想一下，如同天注定，每一个选择都会在未来的某个日子为之而感动。抛去思想阴霾，制定合理的学习计划，不断提升自身价值。在最好的时代，做一个了不起的梦。 </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>深造</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建个人博客</title>
    <url>/2020/02/12/%E6%95%99%E7%A8%8B/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>博客是记录成长与进步的最好工具  </p>
</blockquote>
<h2 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1 安装软件"></a>1 安装软件</h2><p>安装git  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure>
<p>安装Node.js  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -</span><br><span class="line">$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>
<p>安装Hexo  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<p>新建工作空间  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>其中_config.yml文件配置网站信息;　source存放用户资源数据;　themes存放博客主题.  </p>
<h2 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h2><p>优雅的主题能够给人带来美感和创作的源泉, 本博客采用的主题为<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a>. 可根据个人审美选择偏爱的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>.首先将主题文件下载到theme文件夹中  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>
<p>将工作空间根目录下的_config.yml中的theme值修改为ayer  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: ayer</span><br></pre></td></tr></table></figure>
<p>其中主题的细节配置可通过修改新下载主题ayer文件夹中的_config.yml文件, 详细内容可参阅<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">ayer官方文档</a>.</p>
<h2 id="3-GitHub配置"><a href="#3-GitHub配置" class="headerlink" title="3 GitHub配置"></a>3 GitHub配置</h2><p>生成GitHub的SSH Key  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"email of github account"</span></span><br></pre></td></tr></table></figure>
<p>复制 ~/.ssh/id_rsa.pub 文件中的内容, 将其粘贴到”GitHub-&gt;Setting-&gt;SSH and GPG Keys-&gt;New SSH key”中, 并新建以”liuhang0727.github.io”命名的仓库.  </p>
<h2 id="4-部署测试"><a href="#4-部署测试" class="headerlink" title="4 部署测试"></a>4 部署测试</h2><p>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>修改工作空间根目录下的_config.yml中的deploy值  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:liuhang0727/liuhang0727.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>远程部署  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入 <a href="https://liuhang0727.github.io" target="_blank" rel="noopener">https://liuhang0727.github.io</a> 即可查看搭建的博客.  </p>
<h2 id="5-新建博客"><a href="#5-新建博客" class="headerlink" title="5 新建博客"></a>5 新建博客</h2><p>可通过命令行新建文章  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new &lt;模板&gt;　&lt;文章名&gt;</span><br></pre></td></tr></table></figure>
<p>其中模板包括post, draft和page三类, 详细介绍可参阅<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>. 新建的文件存放在source/_post/*.md, 可使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>进行Markdown文本编辑, Markdown语法可参考<a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">博客</a>.　在完成创作后, 可发布部署  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>更多信息，请参阅Hexo<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>.  </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<blockquote>
<p>SLAM初级玩家、DL调参侠、自动驾驶幻想师、二流程序员、摄影爱好者</p>
</blockquote>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>姓名: 刘行<br>家乡: 河南漯河<br>现居: 上海杨浦  </p>
<h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><p>2013.09-2017.06　河南理工大学　测绘工程　学士学位<br>2017.09-2020.06　　同济大学　　测绘工程　硕士学位  </p>
<a id="more"></a>  

<h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h3><p>2018.09-2019.09　Momenta　自动驾驶　Lidar高精度定位算法研发  </p>
<h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p>2020.04-今　SenseTime　自动驾驶　自动驾驶系统开发  </p>
<h3 id="论文专利"><a href="#论文专利" class="headerlink" title="论文专利"></a>论文专利</h3><p>[1] <a href="https://www.mdpi.com/2072-4292/11/11/1348" target="_blank" rel="noopener">Liu, H.; Ye, Q.; Wang, H.R.; Chen, L.; Yang, J. A Precise and Robust Segmentation-based Lidar<br>Localization System for Automated Urban Driving. Remote Sensing. 2019, 11, 1348. (SCI，Q1)</a><br>[2] 刘行, 王海瑞, 陈亮. 一种适于交叉路段的道路边沿提取方法及装置. 2019. (已受理)</p>
<h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p>GitHub: <a href="https://github.com/liuhang0727" target="_blank" rel="noopener">liuhang0727</a><br>E-Mail: <a href="mailto:liuhang@tongji.edu.cn">liuhang@tongji.edu.cn</a><br>CSDN: <a href="https://blog.csdn.net/liudahanghang" target="_blank" rel="noopener">liu_hang_07_27</a><br>知乎: <a href="https://www.zhihu.com/people/liu-xing-52-47-87" target="_blank" rel="noopener">刘行</a><br>豆瓣: <a href="https://www.douban.com/people/185232228/" target="_blank" rel="noopener">刘行</a><br>微博: <a href="https://weibo.com/1819383450/profile?topnav=1&wvr=6" target="_blank" rel="noopener">刘大航航</a><br>微信: <a href="https://wx.qq.com/" target="_blank" rel="noopener">HXXH727</a>  </p>
<p><a href="../files/About/resume_liuhang_20190918.pdf">Resume</a></p>
]]></content>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Album</title>
    <url>/album/index.html</url>
    <content><![CDATA[<blockquote>
<p>可以拿去吹13的照骗 – Photoed by Hang  </p>
</blockquote>
<p><img src="../../../../../files/Album/%E5%A4%96%E6%BB%A9.jpg" alt="外滩" title="外滩">  </p>
<p><img src="../../../../../files/Album/%E9%99%86%E5%AE%B6%E5%98%B4.jpg" alt="陆家嘴" title="陆家嘴">  </p>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
