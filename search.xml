<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Album</title>
    <url>/2020/10/05/album/album/</url>
    <content><![CDATA[<blockquote>
<p>可以拿去吹13的照骗   — Photoed by Hang  </p>
</blockquote>
<h1 id="硕士毕业照"><a href="#硕士毕业照" class="headerlink" title="硕士毕业照"></a>硕士毕业照</h1><blockquote>
<p>匆匆的领证走人  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_4.jpg" alt="毕业照_4"><br><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_5.jpg" alt="毕业照_5">  </p>
<blockquote>
<p>再也回不去的课堂  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_0.jpg" alt="毕业照_0"><br><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_10.jpg" alt="毕业照_10">  </p>
<blockquote>
<p>优秀的标签从此之后就要被摘下啦  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_1.jpg" alt="毕业照_1">  </p>
<blockquote>
<p>国立柱前拍照示例 (请不要再跑到跟前拍啦  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_11.jpg" alt="毕业照_11">  </p>
<blockquote>
<p>小桥流水前 (那些年，在这里线上秋招面试  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_6.jpg" alt="毕业照_6"><br><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_9.jpg" alt="毕业照_9">  </p>
<blockquote>
<p>戴起口罩纪念疫情呀  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_7.jpg" alt="毕业照_7"><br><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_8.jpg" alt="毕业照_8">  </p>
<blockquote>
<p>连路标都是值得怀念的  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_2.jpg" alt="毕业照_2">  </p>
<blockquote>
<p>从ofo到美团 …  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AF%95%E4%B8%9A%E7%85%A7_3.jpg" alt="毕业照_3">  </p>
<h1 id="同济大学"><a href="#同济大学" class="headerlink" title="同济大学"></a>同济大学</h1><blockquote>
<p>国立柱的秋天  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_0.jpg" alt="同济大学_0">  </p>
<blockquote>
<p>国立柱的冬天  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_1.jpg" alt="同济大学_1">  </p>
<blockquote>
<p>图书馆 (爱就像蓝天白云~  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_2.jpg" alt="同济大学_2">  </p>
<blockquote>
<p>图书馆的另一个样子 (上过官方微博哦  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_6.jpg" alt="同济大学_6"><br><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_7.jpg" alt="同济大学_7">  </p>
<blockquote>
<p>同济楼中楼 (一跃解千愁…  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_3.jpg" alt="同济大学_3">  </p>
<blockquote>
<p>彰武路校区的冬天  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_4.jpg" alt="同济大学_4">  </p>
<blockquote>
<p>樱花季  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_5.jpg" alt="同济大学_5">  </p>
<blockquote>
<p>(Photoed by WanYihao，2020年的疫情使我们错过了再同济的最后一次樱花季  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_8.jpg" alt="同济大学_8">  </p>
<blockquote>
<p>同济的猫  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_9.jpg" alt="同济大学_9"><br><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_10.jpg" alt="同济大学_10">  </p>
<blockquote>
<p>中德学部  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_11.jpg" alt="同济大学_11">  </p>
<blockquote>
<p>同济大学校门  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A6_12.jpg" alt="同济大学_12">  </p>
<h1 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h1><blockquote>
<p>清华科技园  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B8%85%E5%8D%8E%E7%A7%91%E6%8A%80%E5%9B%AD.jpg" alt="清华科技园">  </p>
<blockquote>
<p>故宫  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%95%85%E5%AE%AB_0.jpg" alt="故宫_0">  </p>
<h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><blockquote>
<p>武康路 (打卡圣地呀~  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%AD%A6%E5%BA%B7%E8%B7%AF_0.jpg" alt="武康路_0">  </p>
<blockquote>
<p>金灿灿的外滩  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%A4%96%E6%BB%A9.jpg" alt="外滩">  </p>
<blockquote>
<p>陆家嘴 (人生彷徨的时候可以来这里思考人生  </p>
</blockquote>
<p><img src="../../../../../files/album/%E9%99%86%E5%AE%B6%E5%98%B4.jpg" alt="陆家嘴">  </p>
<blockquote>
<p>商汤科技大厦对面的科技园  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_0.jpg" alt="漕河泾_0"><br><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_3.jpg" alt="漕河泾_3"><br><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_4.jpg" alt="漕河泾_4"><br><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_6.jpg" alt="漕河泾_6">  </p>
<blockquote>
<p>天桥的风景真好呀 (车水马龙  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_1.jpg" alt="漕河泾_1">  </p>
<blockquote>
<p>是我的商汤呀  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%BC%95%E6%B2%B3%E6%B3%BE_5.jpg" alt="漕河泾_5">  </p>
<h1 id="徐州"><a href="#徐州" class="headerlink" title="徐州"></a>徐州</h1><blockquote>
<p>矿大风筝王  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%BE%90%E5%B7%9E_0.jpg" alt="徐州_0">  </p>
<h1 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h1><blockquote>
<p>第一次坐飞机 (祖国的的大好河山真美丽呀~  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B7%B1%E5%9C%B3_0.jpg" alt="深圳_0">  </p>
<blockquote>
<p>深圳宝安国际机场  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B7%B1%E5%9C%B3_2.jpg" alt="深圳_2">  </p>
<blockquote>
<p>何香凝艺术馆 (没有提前预约只能在外边团团转，疫情真讨厌 …  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B7%B1%E5%9C%B3_1.jpg" alt="深圳_1">  </p>
<blockquote>
<p>纪念伟大的邓爷爷  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B7%B1%E5%9C%B3_3.jpg" alt="深圳_3">  </p>
<blockquote>
<p>免费的大床真舒服呀  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B7%B1%E5%9C%B3_4.jpg" alt="深圳_4">  </p>
<h1 id="连云港"><a href="#连云港" class="headerlink" title="连云港"></a>连云港</h1><blockquote>
<p>海岛  </p>
</blockquote>
<p><img src="../../../../../files/album/%E8%BF%9E%E4%BA%91%E6%B8%AF_0.jpg" alt="连云港_0">  </p>
<h1 id="博物馆"><a href="#博物馆" class="headerlink" title="博物馆"></a>博物馆</h1><blockquote>
<p>上海博物馆展品  </p>
</blockquote>
<p><img src="../../../../../files/album/%E4%B8%8A%E6%B5%B7%E5%8D%9A%E7%89%A9%E9%A6%86_0.jpg" alt="上海博物馆_0"><br><img src="../../../../../files/album/%E4%B8%8A%E6%B5%B7%E5%8D%9A%E7%89%A9%E9%A6%86_1.jpg" alt="上海博物馆_1">  </p>
<blockquote>
<p>世博会博物馆  </p>
</blockquote>
<p><img src="../../../../../files/album/%E4%B8%96%E5%8D%9A%E4%BC%9A%E5%8D%9A%E7%89%A9%E9%A6%86_0.jpg" alt="世博会博物馆_0"><br><img src="../../../../../files/album/%E4%B8%96%E5%8D%9A%E4%BC%9A%E5%8D%9A%E7%89%A9%E9%A6%86_1.jpg" alt="世博会博物馆_1">  </p>
<h1 id="油画"><a href="#油画" class="headerlink" title="油画"></a>油画</h1><blockquote>
<p>油画处女作  </p>
</blockquote>
<p><img src="../../../../../files/album/%E6%B2%B9%E7%94%BB.jpg" alt="油画">  </p>
<h1 id="厨艺"><a href="#厨艺" class="headerlink" title="厨艺"></a>厨艺</h1><blockquote>
<p>是李大厨啊  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_0.jpg" alt="厨艺_0"><br><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_1.jpg" alt="厨艺_1"><br><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_2.jpg" alt="厨艺_2"><br><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_3.jpg" alt="厨艺_3">  </p>
<blockquote>
<p>中秋礼盒的茶叶好香呀  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_4.jpg" alt="厨艺_4">  </p>
<blockquote>
<p>2020 - 1995 = 25 (岁生日  </p>
</blockquote>
<p><img src="../../../../../files/album/%E5%8E%A8%E8%89%BA_5.jpg" alt="厨艺_5">  </p>
<h1 id="实验Demo"><a href="#实验Demo" class="headerlink" title="实验Demo"></a>实验Demo</h1><blockquote>
<p>记录一下插入视频的语法  </p>
</blockquote>
<p><video src='../../../../../files/album/demo.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video></p>
]]></content>
  </entry>
  <entry>
    <title>随笔_20201005</title>
    <url>/2020/10/05/%E9%9A%8F%E7%AC%94/essay_20201005/</url>
    <content><![CDATA[<blockquote>
<p>每个优秀的人，都有一段沉默的时光。那段时光，是付出了很多努力却得不到结果的日子，我们把它叫做<strong>扎根</strong>   – Chairman Xi  </p>
</blockquote>
<p>最近读到这段话，触动颇深。倒不是回想到了自己的某段艰苦的扎根时光，而是觉得当前的日子显得太过于安逸，根不深则身不固，是否应该做些更有挑战性的事情呢？  </p>
<a id="more"></a>  

]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_课程</title>
    <url>/2020/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-设计模式简介"><a href="#1-设计模式简介" class="headerlink" title="1 设计模式简介"></a><a href="https://www.bilibili.com/video/BV1kW411P7KS?p=1" target="_blank" rel="noopener">1 设计模式简介</a></h2><ul>
<li>从面向对象谈起：  <ul>
<li>底层思维：向下，如何把握机器底层，从微观理解对象构造  <blockquote>
<p>语言构造<br>编译转换<br>内存模型<br>运行时机制  </p>
</blockquote>
</li>
<li>抽象思维：向上，如何将我们的周围世界抽象为程序代码  <blockquote>
<p>面向对象<br>组件封装<br>设计模式<br>架构模式  </p>
</blockquote>
</li>
</ul>
</li>
<li>如何解决复杂性？  <ul>
<li>分解。(即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题  </li>
<li>抽象。(由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型  </li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>设计模式分类：  <ul>
<li>组件协作 (现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过<strong>晚期绑定</strong>，实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式)，包括:  <blockquote>
<p>Template Method<br>Strategy<br>Observer / Event  </p>
</blockquote>
</li>
<li>单一职责  <blockquote>
<p>Decorator<br>Bridge  </p>
</blockquote>
</li>
<li>创建对象  <blockquote>
<p>Factory Method<br>Abstract Factory<br>Prototype<br>Builder  </p>
</blockquote>
</li>
<li>对象性能  <blockquote>
<p>Singleton<br>Flyweight  </p>
</blockquote>
</li>
<li>接口隔离  <blockquote>
<p>Facade<br>Proxy<br>Mediator<br>Adapter  </p>
</blockquote>
</li>
<li>状态变化  <blockquote>
<p>Memento<br>State</p>
</blockquote>
</li>
<li>数据结构<blockquote>
<p>Composite<br>Iterator<br>Chain of Resposibility  </p>
</blockquote>
</li>
<li>行为变化  <blockquote>
<p>Command<br>Visitor  </p>
</blockquote>
</li>
<li>领域问题  <blockquote>
<p>Interpreter  </p>
</blockquote>
</li>
</ul>
</li>
<li>重构获得模式(Refactoring to Patterns)。  </li>
<li>重构关键技法：  <ul>
<li>静态 –&gt; 动态  </li>
<li>早绑定 –&gt; 晚绑定  </li>
<li>继承 –&gt; 组合  </li>
<li>编译时依赖 –&gt; 运行时依赖  </li>
<li>紧耦合 –&gt; 松耦合  </li>
</ul>
</li>
</ul>
<h2 id="2-面向对象设计原则"><a href="#2-面向对象设计原则" class="headerlink" title="2 面向对象设计原则"></a><a href="https://www.bilibili.com/video/BV1kW411P7KS?p=2" target="_blank" rel="noopener">2 面向对象设计原则</a></h2><ul>
<li>依赖倒置原则(DIP)  <ul>
<li>高层模块(<strong>稳定</strong>)不应该依赖于低层模块(<strong>变化</strong>)，二者都应该依赖于抽象(<strong>稳定</strong>)。  </li>
<li>抽象(<strong>稳定</strong>)不应该依赖于实现细节(<strong>变化</strong>)，实现细节应该依赖于抽象(<strong>稳定</strong>)。  </li>
</ul>
</li>
<li>开放封闭原则(OCP)  <ul>
<li>对扩展开放，对更改封闭。  </li>
<li>类模块应该是可扩展的，但是不可修改。  </li>
</ul>
</li>
<li>单一职责原则(SRP)  <ul>
<li>一个类应该仅有一个引起它变化的原因。  </li>
<li>变化的方向隐含着类的<strong>责任</strong>。  </li>
</ul>
</li>
<li>Liskov替换原则(LSP)  <ul>
<li>子类必须能够替换他们的基类(IS-A)。  </li>
<li>继承表达类型抽象。  </li>
</ul>
</li>
<li>接口隔离原则(ISP)  <ul>
<li>不应该强迫客户程序依赖他们不用的方法。  </li>
<li>接口应该小而完备。(public/private  </li>
</ul>
</li>
<li>优先使用对象组合，而不是类继承  <ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。  </li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。  </li>
<li>对象组合只要求被组合的对象具有良好定义的接口，耦合度低。  </li>
</ul>
</li>
<li>封装变化点  <ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次之间的松耦合。  </li>
</ul>
</li>
<li>针对接口编程，而不是针对实现编程  <ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。  </li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。  </li>
<li>减少系统中各部分的依赖关系，从而实现“<strong>高内聚、松耦合</strong>”的类型设计方案。  </li>
</ul>
</li>
</ul>
<h2 id="3-模板方法模式-Template-Method"><a href="#3-模板方法模式-Template-Method" class="headerlink" title="3 模板方法模式(Template Method)"></a><a href="https://www.bilibili.com/video/BV1kW411P7KS?p=3" target="_blank" rel="noopener">3 模板方法模式(Template Method)</a></h2><ul>
<li>定义：<ul>
<li>定义一个操作中的算法骨架(<strong>稳定</strong>)，而将一些步骤(<strong>变化</strong>)延迟(<strong>虚函数重写</strong>)到子类中。Template Method使得子类可以不改变(<strong>复用</strong>)一个算法的结构即可重定义(<strong>override</strong>)该算法的某些特定步骤。  </li>
</ul>
</li>
<li>结构：( <em>红色不变，蓝色变化</em><br><img src="../../../../../files/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式" title="模板方法模式">  </li>
<li>要点：<ul>
<li>Template Method模式使用最简单的机制(<strong>虚函数的多态性</strong>)，为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。  </li>
<li>“不要调用我，让我调用你”的反向控制结构是Template Method的典型应用。  </li>
</ul>
</li>
</ul>
<h2 id="4-策略模式-Strategy"><a href="#4-策略模式-Strategy" class="headerlink" title="4 策略模式(Strategy)"></a>4 策略模式(Strategy)</h2><p><a href="https://www.bilibili.com/video/BV1kW411P7KS?p=4" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>动机：  <ul>
<li>在软件构建过程中，某些对象使用的算法可能是多种多样经常改变的，如果将这些算法都编码到对象中，将会使对象变的异常复杂，而且有时候支持不适用的算法也是一种性能负担。  </li>
<li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？  </li>
</ul>
</li>
<li>定义：  <ul>
<li>定义一些列算法，把他们一个个封装起来，并且使他们可互相替换(<strong>变化</strong>)。该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。  </li>
</ul>
</li>
<li>结构：<br><img src="../../../../../files/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt="策略模式结构" title="策略模式结构">  </li>
<li>要点：  <ul>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而使得类型在<strong>运行时</strong>方便地根据需要在各个算法之间进行切换。  </li>
<li>Strategy模式提供了用条件判断语句(<code>if else</code> / <code>switch case</code>)以外的另一种选择，消除条件判断语句，就是在<strong>解耦合</strong>。含有许多条件判断语句的代码通常都需要Strategy模式。  </li>
<li>如果Strategy对象没有实例变量，那么各个上下文可共享同一个Strategy对象，从而节省对象开销。  </li>
</ul>
</li>
</ul>
<h2 id="5-观察者模式-Observer-Event"><a href="#5-观察者模式-Observer-Event" class="headerlink" title="5 观察者模式(Observer / Event)"></a><a href="https://www.bilibili.com/video/BV1kW411P7KS?p=5" target="_blank" rel="noopener">5 观察者模式(Observer / Event)</a></h2><ul>
<li>动机：  <ul>
<li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”，一个对象(目标对象)的状态发生变化，所有的依赖对象(观察者对象)都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。  </li>
<li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系，从而实现软件体系结构的松耦合。  </li>
</ul>
</li>
<li>定义：  <ul>
<li>定义对象间的一种<strong>一对多</strong>(变化)的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并更新。  </li>
</ul>
</li>
<li>结构：  <ul>
<li><img src="../../../../../files/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式结构" title="观察者模式结构">  </li>
</ul>
</li>
<li>要点：  <ul>
<li>使用面向对象的抽象，Observer模式使得我们可以<strong>独立地</strong>改变目标与观察者，从而使二者之间的依赖关系达到松耦合。  </li>
<li>目标发送通知时，无需指定观察者，通知(可以携带通知信息作为参数)会自动传播。  </li>
<li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。  </li>
<li>Observer模式是基于事件的UI跨国家中非常常用的设计模式，也是MVC模式的重要组成部分。  </li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_多线程</title>
    <url>/2020/07/12/C++/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_新特性</title>
    <url>/2020/07/12/C++/C++_%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="01-nullptr与constexptr"><a href="#01-nullptr与constexptr" class="headerlink" title="01 nullptr与constexptr"></a>01 <code>nullptr</code>与<code>constexptr</code></h2><p><a href="https://www.bilibili.com/video/BV1pk4y1z7JT" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>nullptr</code>表示空指针，本质还是<code>0</code>,但具备了类型。  </li>
<li>建议程序中使用<code>nullptr</code>代替<code>NULL</code>。  </li>
<li><code>constexptr</code>常量表示式关键字，用于修饰函数。  </li>
</ul>
<h2 id="02-迭代器与类型推导auto"><a href="#02-迭代器与类型推导auto" class="headerlink" title="02 迭代器与类型推导auto"></a>02 迭代器与类型推导<code>auto</code></h2><p><a href="https://www.bilibili.com/video/BV1Hi4y1G74C" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>stl</code>中存在一些常用的封装好的数据结构相关的模板类(容器)，例如<code>vector(动态数据)</code>，<code>list(链表)</code>，<code>stack(栈)</code>，<code>queue(队列)</code>，<code>map(hash表/红黑树)</code>等。  </li>
<li>这些类通常都具有一些最基本的操作，例如增加，删除，修改，遍历等。  </li>
<li><code>C++</code>为了方便统一，采用了设计模式中的<code>迭代器模式</code>，统一的提供了一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">// 迭代器，模板类中的内部类</span></span><br><span class="line"><span class="keyword">for</span>(it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// *it来访问模板类的具体值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>auto</code>类型推导关键字，简洁代码。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : v) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>auto</code>不能用于函数传参。  </li>
</ul>
<a id="more"></a>  

<h2 id="03-委托构造与继承构造"><a href="#03-委托构造与继承构造" class="headerlink" title="03 委托构造与继承构造"></a>03 委托构造与继承构造</h2><p><a href="https://www.bilibili.com/video/BV1dt4y1X7eB" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>委托构造指在类中的一个构造函数中调用另一个构造函数，从而达到简化代码的目的。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i1, i2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        v1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base() &#123;  <span class="comment">// 委托Base()构造函数</span></span><br><span class="line">        v2 = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用<code>using</code>关键字引入继承构造概念，实现在子类中完成父类构造函数的调用。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i1, i2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        v1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> v) : Base() &#123;  <span class="comment">// 委托Base()构造函数</span></span><br><span class="line">        v2 = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 直接使用父类的构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="04-override，final，default和delete关键字"><a href="#04-override，final，default和delete关键字" class="headerlink" title="04 override，final，default和delete关键字"></a>04 <code>override</code>，<code>final</code>，<code>default</code>和<code>delete</code>关键字</h2><p><a href="https://www.bilibili.com/video/BV1xk4y1z7zh" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>override</code>关键字显示地告知编译器进行虚函数的重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译。  </li>
<li><code>final</code>关键字修饰类或函数，表示该类不能在被继承，或该函数不能再被重载。  </li>
<li><code>default</code>关键字希望编译器产生默认构造函数。  </li>
<li><code>delete</code>关键字不让编译器产生默认构造函数。  </li>
</ul>
<h2 id="05-强制转换const-cast"><a href="#05-强制转换const-cast" class="headerlink" title="05 强制转换const_cast"></a>05 强制转换<code>const_cast</code></h2><p><a href="https://www.bilibili.com/video/BV1jV41167VK" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>强制类型转换<code>(type)vari</code>使存在风险的，如把<code>整型</code>数值转换为<code>指针</code>，把<code>基类指针</code>转换为<code>派生类指针</code>，把<code>一种函数指针</code>转换成<code>另一种函数指针</code>，把<code>常量指针</code>转换成<code>非常量</code>指针。  </li>
<li><code>c++</code>引入四种功能不同的强制类型转换运算符：<code>const_cast</code>，<code>static_cast</code>，<code>reinterpret_cast</code>和<code>dynamic_cast</code>。  </li>
<li>克服了<code>c</code>语言强制类型转换的三个缺点：<br>  1 没有从形式上体现转换功能和风险的不同。<br>  2 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。<br>  3 难以在程序中找到到底哪个地方进行了强制类型转换。  </li>
<li><code>const_cast</code>仅用于去除<code>const</code>属性的转换，它也是四种强制类型转换运算符中唯一能够去除<code>const</code>属性的运算符。  </li>
<li>常量对象或者是基本数据类型不允许转化为非常量对象，只能通过指针，引用或<code>this</code>指针修改。  </li>
</ul>
<h2 id="06-强制转换static-cast"><a href="#06-强制转换static-cast" class="headerlink" title="06 强制转换static_cast"></a>06 强制转换<code>static_cast</code></h2><p><a href="https://www.bilibili.com/video/BV1iK411n7os" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>基本等价于隐式转换的一种类型转换运算符，可使用于需要明确隐式转换的地方。  </li>
<li>可用于低风险的转换：<br>  1 整型和浮点型<br>  2 字符与整型<br>  3 转换运算符<br>  4 空指针(<code>void* p = nullptr</code>)转换为任何目标类型的指针  </li>
<li>不可用于风险高的转换：<br>  1 不同类型的指针间转换<br>  2 整型和指针之间的转换<br>  3 不同类型的引用之间转换  </li>
</ul>
<h2 id="07-强制转换dynamic-cast"><a href="#07-强制转换dynamic-cast" class="headerlink" title="07 强制转换dynamic_cast"></a>07 强制转换<code>dynamic_cast</code></h2><p><a href="https://www.bilibili.com/video/BV1FZ4y1p78h" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>用于具有<strong>虚函数的基类</strong>与<strong>派生类</strong>之间的<strong>指针或引用</strong>的转换。  </li>
<li>基类必须具备虚函数。(why，<code>dynamic_cast</code>是<strong>运行时类型检查</strong>，需要运行时类型信息(RTTI)，而这个信息是存储与类的<strong>虚函数表</strong>关系紧密，只有一个类定义了虚函数，才会有虚函数表。  </li>
<li>运行时检查，转型不成功则返回一个空指针。  </li>
<li>非必要不要使用<code>dynamic_cast</code>，有<strong>额外的函数开销</strong>。  </li>
<li>常见的转换方式：<br>  1 基类指针或引用转派生类指针。(<strong>必须使用</strong><code>dynamic_cast</code><br>  2 派生类指针或引用转基类指针。(可以使用<code>dynamic_cast</code>，但更<strong>推荐使用</strong><code>static_cast</code>  </li>
<li>父类转子类(向下转换)是<strong>不安全</strong>的，子类转父类(向上转换)是<strong>安全</strong>的。  </li>
</ul>
<h2 id="08-强制转换reinterpret-cast"><a href="#08-强制转换reinterpret-cast" class="headerlink" title="08 强制转换reinterpret_cast"></a>08 强制转换<code>reinterpret_cast</code></h2><p><a href="https://www.bilibili.com/video/BV1zz4y1X7Ka" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>用于进行各种<strong>高危险</strong>不同类型的转换：<br>  1 不同类型指针之间。<br>  2 不同类型引用之间。<br>  3 指针和能容纳指针的整数类型之间。  </li>
<li>编译器处理，执行是逐字节复制的操作。  </li>
<li>类似于<strong>显示强转</strong>，<strong>后果自负</strong>。  </li>
</ul>
<h2 id="09-lambda表达式与匿名函数"><a href="#09-lambda表达式与匿名函数" class="headerlink" title="09 lambda表达式与匿名函数"></a>09 <code>lambda</code>表达式与匿名函数</h2><p><a href="https://www.bilibili.com/video/BV1CC4y187Km" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>lamba</code>表达式就是匿名函数。  </li>
</ul>
<h2 id="27-线程与同步"><a href="#27-线程与同步" class="headerlink" title="27 线程与同步"></a>27 线程与同步</h2><p><a href="https://space.bilibili.com/477729104/video" target="_blank" rel="noopener">链接_视频</a>  </p>
<p>* </p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_基础知识点_2</title>
    <url>/2020/07/05/C++/C++_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9_2/</url>
    <content><![CDATA[<h2 id="24-常成员函数"><a href="#24-常成员函数" class="headerlink" title="24 常成员函数"></a>24 常成员函数</h2><p><a href="https://www.bilibili.com/video/BV1ET4y1378r" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>用法: 在成员函数后增加<code>const</code>关键字修饰。<code>int GetNum() const;</code>  </li>
<li>作用: 无法修改数据成员，一般用来修饰<code>Get</code>函数。  </li>
<li>本质: 成员函数被<code>const</code>修饰后，<code>this</code>指针的类型由<code>T* const</code>变为<code>const T* const</code>，其中<code>T* const</code>表示该指针本身不能被修改，<code>const T* const</code>表示该指针本身和指针指向的内容均不能被修改。  </li>
<li>意义: 让编译器提醒开发者该函数不能修改类的成员变量，用于<code>const</code>对象(引用或指针)。  </li>
<li><code>mutable</code>关键字能够突破这种限制。<code>mutable int m_num;</code>  </li>
</ul>
<a id="more"></a>  

<h2 id="25-常成员变量及初始化列表"><a href="#25-常成员变量及初始化列表" class="headerlink" title="25 常成员变量及初始化列表"></a>25 常成员变量及初始化列表</h2><p><a href="https://www.bilibili.com/video/BV1RQ4y1N7yQ" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>初始化列表可以用于初始化普通成员变量和常成员变量。  </li>
<li>初始化列表通常是用来构造有参数额成员对象。  </li>
</ul>
<h2 id="26-静态成员变量"><a href="#26-静态成员变量" class="headerlink" title="26 静态成员变量"></a>26 静态成员变量</h2><p><a href="https://www.bilibili.com/video/BV1hV411d7JB" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>使用关键字<code>static</code>修饰。  </li>
<li>要单独的把实现写在类外。(.cpp  </li>
<li>默认会用<code>0</code>对该成员进行初始化。  </li>
<li>静态成员变量是同一个类的不同对象共用的。  </li>
<li>本质: 带类域的全局变量。  </li>
</ul>
<h2 id="27-静态成员函数"><a href="#27-静态成员函数" class="headerlink" title="27 静态成员函数"></a>27 静态成员函数</h2><p><a href="https://www.bilibili.com/video/BV1EZ4y1p7q5" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>在头文件(.h)的函数名前面加上关键字<code>static</code>。  </li>
<li>静态成员函数内部仅能够访问静态的成员变量。  </li>
<li>本质: 静态成员函数中没有<code>this</code>指针；静态成员函数实际上就是带类域的全局函数。  </li>
<li>使用<code>static</code>修饰的成员变量或成员函数，与类的对象是无关的，可通过<code>类名::静态成员变量</code>或<code>类名::静态成员函数</code>直接访问。  </li>
</ul>
<h2 id="28-单例模式"><a href="#28-单例模式" class="headerlink" title="28 单例模式"></a>28 单例模式</h2><p><a href="https://www.bilibili.com/video/BV1Gz4y1d7RJ" target="_blank" rel="noopener">链接_视频</a><br><a href="https://liuhang0727.github.io/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">链接_blog</a>  </p>
<h2 id="29-友元的实现及作用"><a href="#29-友元的实现及作用" class="headerlink" title="29 友元的实现及作用"></a>29 友元的实现及作用</h2><p><a href="https://www.bilibili.com/video/BV1AK4y1t76J" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>使用关键<code>friend</code>修饰。  </li>
<li>作用: 可以访问一个类的私有成员。  </li>
<li>分类: 友元全局函数；友元成员函数；友元类。  </li>
<li>缺点: 破坏了类的封装和数据的隐藏性。  </li>
<li>用途: 不推荐使用，在某些方面，如运算符重载和某些软件设计时可酌情使用。  </li>
</ul>
<h2 id="30-虚析构函数的作用"><a href="#30-虚析构函数的作用" class="headerlink" title="30 虚析构函数的作用"></a>30 虚析构函数的作用</h2><p><a href="https://www.bilibili.com/video/BV1BA411t7K9" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>当存在继承时，将父类和子类的析构函数均通过<code>virtual</code>关键字定义为虚函数，可避免子类的析构函数未被调用。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类赋值给父类是安全的</span></span><br><span class="line"><span class="comment">// 当子类和父类的析构函数不是虚函数时，在delete时子类的析构函数未被调用</span></span><br><span class="line">CParent* p = <span class="keyword">new</span> CChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// 等价于 &lt;==&gt;</span></span><br><span class="line">p-&gt;~CParent();  <span class="comment">// 间接调用，查子类虚表，子类虚表第0项目--子类的析构</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="31-虚函数的多态性"><a href="#31-虚函数的多态性" class="headerlink" title="31 虚函数的多态性"></a>31 虚函数的多态性</h2><p><a href="https://www.bilibili.com/video/BV1pi4y147dZ" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>有点懵逼…  </li>
<li>普通的成员函数中，调用虚函数具有多态性。(间接调用，看虚表  </li>
<li>在构造函数中调用虚表，实际上是直接调用，所以没有多态。  </li>
<li>在构造函数中调用普通成员函数，该成员函数中有虚函数的间接调用，由于进入构造时，会为对象赋值为当前类的虚表，所以没有多态。  </li>
</ul>
<h2 id="32-纯虚函数与抽象类"><a href="#32-纯虚函数与抽象类" class="headerlink" title="32 纯虚函数与抽象类"></a>32 纯虚函数与抽象类</h2><p><a href="https://www.bilibili.com/video/BV1XK411W7Ex" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>在虚函数的后面加上<code>= 0</code>，表示该函数不需要实现代码，也代表该类不能实例化。  </li>
<li>纯虚函数如果没有实现，那么包含该纯虚函数的类是抽象类。  </li>
<li>抽象类不能实例化。  </li>
<li>接口类: 只是作为父类，规范子类对外使用的接口。(某些函数，可以是虚函数，不一定包含虚函数  </li>
<li>抽象类: 一定要包含某一个纯虚函数，并且没有被实现。  </li>
<li>纯虚析构一定要有实现。  </li>
</ul>
<h2 id="33-多重继承"><a href="#33-多重继承" class="headerlink" title="33 多重继承"></a>33 多重继承</h2><p><a href="https://www.bilibili.com/video/BV1bk4y167iT" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>同时具备多个父类的特点。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFather1</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFather2</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cchild</span> :</span> <span class="keyword">public</span> CFather1, <span class="keyword">public</span> CFather2 &#123; &#125;;</span><br></pre></td></tr></table></figure></li>
<li>多使用类的组合，少使用多重继承。  </li>
</ul>
<h2 id="34-菱形继承与虚继承"><a href="#34-菱形继承与虚继承" class="headerlink" title="34 菱形继承与虚继承"></a>34 菱形继承与虚继承</h2><p><a href="https://www.bilibili.com/video/BV1V5411s744" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>菱形继承导致的<code>爷类</code>(hhhhh)中的数据成员和成员函数是多份的问题，可以通过虚继承来解决。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGrandfather</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFather1</span> :</span> <span class="keyword">virtual</span> Public CGrandfather &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFather2</span> :</span> <span class="keyword">virtual</span> Public CGrandfather &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CChild</span> :</span> <span class="keyword">public</span> CFather1, <span class="keyword">public</span> CFather2 &#123; &#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="35-运算符重载"><a href="#35-运算符重载" class="headerlink" title="35 运算符重载"></a>35 运算符重载</h2><p><a href="https://www.bilibili.com/video/BV13A411q7bE" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>定义: 重载已有运算符，赋于新的功能。  </li>
<li>方式: 成员函数重载；友元全局函数重载。  </li>
<li>特点: 不破坏原有运算符的功能；运算符的优先级不变；使用方式要保持不变。  </li>
<li>作用: 代码简洁。  </li>
<li>可以重载的运算符:<br>  <code>+ - * / % ^ &amp; | ~</code><br>  <code>! = &lt; &gt; += -= *= /= %=</code><br>  <code>^= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == !=</code><br>  <code>&lt;= &gt;= &amp;&amp; || ++ -- [] () -&gt;</code><br>  <code>, new new[] delete delete[]</code>  </li>
<li>不能重载的运算符:<br>  <code>. :: ?: #</code>  </li>
<li>运算符的重载本质是函数的调用。(<code>operator=</code>  </li>
<li><code>new</code>和<code>delete</code>并不是关键字，而是运算符。  </li>
</ul>
<h2 id="36-cin与cout的奥秘"><a href="#36-cin与cout的奥秘" class="headerlink" title="36 cin与cout的奥秘"></a>36 <code>cin</code>与<code>cout</code>的奥秘</h2><p><a href="https://www.bilibili.com/video/BV1kC4y1H7G7" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1eC4y1H7uC" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li><code>cout</code>是类<code>ostream</code>的对象。  </li>
<li><code>cin</code>是类<code>istream</code>的对象。  </li>
<li><code>endl</code>是函数。  </li>
<li><code>&lt;&lt;</code>是一种运算符重载，重载了字符串，整型，<code>endl</code>等函数的指针。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="37-转换运算符"><a href="#37-转换运算符" class="headerlink" title="37 转换运算符"></a>37 转换运算符</h2><p><a href="https://www.bilibili.com/video/BV15z411B7W8" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>运算符重载的优先级高于转换运算符号。  </li>
</ul>
<h2 id="38-函数模板"><a href="#38-函数模板" class="headerlink" title="38 函数模板"></a>38 函数模板</h2><p><a href="https://www.bilibili.com/video/BV1Ug4y1B78H" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>核心: 把某些类型(<code>int</code>, <code>double</code> … )当作是变量。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">GetMin</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数模板的隐式实例化。(由编译器去猜测函数模板的类型    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetMin(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">GetMin(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure></li>
<li>显示实例化。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GetMin&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure></li>
<li>模板的特例化。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">GetMin</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">char</span>* b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="39-类模板"><a href="#39-类模板" class="headerlink" title="39 类模板"></a>39 类模板</h2><p><a href="https://www.bilibili.com/video/BV1NC4y1p7FB" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>类的声明和实现都要放在<code>.h</code>文件中。  </li>
</ul>
<h2 id="40-异常处理"><a href="#40-异常处理" class="headerlink" title="40 异常处理"></a>40 异常处理</h2><p><a href="https://www.bilibili.com/video/BV1iA411q7hx" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>捕捉运行时的错误。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认为抛异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(···) &#123;</span><br><span class="line">    <span class="comment">// ···表示所有类型的异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="built_in">std</span>::<span class="built_in">string</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_基础知识点_1</title>
    <url>/2020/07/05/C++/C++_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9_1/</url>
    <content><![CDATA[<h2 id="0-默认参"><a href="#0-默认参" class="headerlink" title="0 默认参"></a>0 默认参</h2><p><a href="https://www.bilibili.com/video/BV1SE411i7sj" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>函数允许提供默认参。  </li>
<li>默认参数可以写在声明或定义处，但只能出现在一个地方，一般写在声明处。  </li>
<li>当一个参数有默认参时，该参数右边必须都出现默认参。  </li>
</ul>
<a id="more"></a>  

<h2 id="1-const常量"><a href="#1-const常量" class="headerlink" title="1 const常量"></a>1 const常量</h2><p><a href="https://www.bilibili.com/video/BV1SE411i7JK" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>const</code>用于修饰变量，将变量变为常量，常量一旦定义，就不可以修改。  </li>
<li>编译器在程序的编译时期做的检查，即定义后是不可以通过赋值修改的，但在运行时期时可以修改的。  </li>
</ul>
<h2 id="2-const指针"><a href="#2-const指针" class="headerlink" title="2 const指针"></a>2 const指针</h2><p><a href="https://www.bilibili.com/video/BV1SE411i7jL" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>const T*</code>表示不能修改指针指向的内容，指针本身的值可以修改。  </li>
<li><code>T const*</code>同<code>const T*</code>，表示不能修改指针指向的内容，指针本身的值可以修改。  </li>
<li><code>T* const</code>表示该指针是一个常量，意味着指针本身的值不能被修改，但是指针指向的内容可以修改。  </li>
<li><code>const T* const</code>表示指针指向的内容和指针本身均不能被修改。  </li>
<li><code>const_cast</code>类型转换可以用于去除<code>const</code>修饰。  </li>
</ul>
<h2 id="3-内联函数"><a href="#3-内联函数" class="headerlink" title="3 内联函数"></a>3 内联函数</h2><p><a href="https://www.bilibili.com/video/BV1SE411i7sq" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li><code>inline</code>函数能够节省进出函数的系统的耗时。  </li>
<li><code>inline</code>是对编译器的建议，编译器可以根据函数的大小自动选择是否内联。  </li>
<li><code>debug</code>版本没有<code>inline</code>，为了方便调试。  </li>
<li>内联函数必须写在头文件中。  </li>
</ul>
<h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4 引用"></a>4 引用</h2><p><a href="https://www.bilibili.com/video/BV1NJ411278G" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1NJ41127tq" target="_blank" rel="noopener">链接_视频_2</a><br><a href="https://www.bilibili.com/video/BV1NJ41127ib" target="_blank" rel="noopener">链接_视频_3</a>  </p>
<ul>
<li>引用<code>&amp;</code>是变量的别名。  </li>
<li>引用在定义时必须初始化，且不能使用常量为引用赋值。  </li>
<li>只有常量引用可以使用常量来初始化。<code>const int&amp; crefN = 12;</code>  </li>
<li>引用的关系一旦建立则无法修改。  </li>
<li>不存在二级引用，可以使用指针的引用来替代二级指针。  </li>
</ul>
<h2 id="5-作用域与数据隐藏"><a href="#5-作用域与数据隐藏" class="headerlink" title="5 作用域与数据隐藏"></a>5 作用域与数据隐藏</h2><p><a href="https://www.bilibili.com/video/BV1NJ41127vn" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>作用域包括全局作用域，名字空间域，局部作用域，块作用域和类作用域。  </li>
<li>在不同的作用域可以定义多个相同名字的变量。  </li>
<li>内部的变量会隐藏外部的变量(从内-&gt;外查找)。  </li>
</ul>
<h2 id="6-名字空间"><a href="#6-名字空间" class="headerlink" title="6 名字空间"></a>6 名字空间</h2><p><a href="https://www.bilibili.com/video/BV1NJ41127eK" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV17J41127VN" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li>关键字<code>namespace</code>  </li>
<li>一种作用域的划分，通常用于区分项目中模块或组件。  </li>
<li>名字空间可以分开使用。(在多个地方使用同一个名字空间  </li>
<li>名字空间可以嵌套。  </li>
<li>名字空间可以取别名。<code>namespace t = test</code>  </li>
<li>单独使用<code>::</code>表示使用全局作用域。  </li>
<li>名字空间的使用方法:<br>  1 直接使用。<code>名字空间::内容</code> (推荐<br>  2 声明名字空间。<code>using namespace 名字空间</code><br>  3 声明只使用名字空间的部分变量或函数。<code>using 名字空间::内容</code>  </li>
</ul>
<h2 id="7-函数重载"><a href="#7-函数重载" class="headerlink" title="7 函数重载"></a>7 函数重载</h2><p><a href="https://www.bilibili.com/video/BV17J411273R" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV17J41127gD" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li>函数重载指<code>C++</code>中相同名字的函数。(C中是不支持重载的  </li>
<li>函数重载的条件: （函数要素：函数名，函数参数，函数返回值，函数的调用约定<br>  1 函数名必须相同。<br>  2 函数参数个数不同，类型不同，顺序不同。<br>  3 函数返回值，调用约定不做考虑。<br>  4 作用域相同。  </li>
</ul>
<h2 id="8-面向对象及类"><a href="#8-面向对象及类" class="headerlink" title="8 面向对象及类"></a>8 面向对象及类</h2><p><a href="https://www.bilibili.com/video/BV17J41127p7" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV17J41127Hn" target="_blank" rel="noopener">链接_视频_2</a><br><a href="https://www.bilibili.com/video/BV17J41127t3" target="_blank" rel="noopener">链接_视频_3</a><br><a href="https://www.bilibili.com/video/BV17J411274c" target="_blank" rel="noopener">链接_视频_4</a>  </p>
<ul>
<li>对象 = 数据(数据类型) + 行为(函数)  </li>
<li>面向对象特点:<br>  1 封装。(数据成员＋成员函数<br>  2 继承。<br>  3 多态。  </li>
<li><code>C++</code>中<code>struct</code>与<code>class</code>的唯一区别就是成员的默认访问权限。(结构体默认是公有<code>public</code>权限，类默认是<code>private</code>权限  </li>
</ul>
<h2 id="9-this指针"><a href="#9-this指针" class="headerlink" title="9 this指针"></a>9 <code>this</code>指针</h2><p><a href="https://www.bilibili.com/video/BV17J41127sw" target="_blank" rel="noopener">链接_视频 (18</a>  </p>
<ul>
<li>同一个类的对象，其成员函数地址是一样的，表示同一个类的对象的成员函数共用的。(数据是独立的，成员函数是共用的  </li>
<li>成员函数调用时会偷偷的传递<code>this</code>指针，通过寄存器<code>ecx</code>传递，这种传递方式称为<code>thiscall</code>。  </li>
</ul>
<h2 id="10-构造函数"><a href="#10-构造函数" class="headerlink" title="10 构造函数"></a>10 构造函数</h2><p><a href="https://www.bilibili.com/video/BV1jJ41127dx" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1jJ41127RB" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li>用于初始化对象的成员。  </li>
<li>由编译器在合适的时机调用。  </li>
<li>不允许有返回值。  </li>
<li>可以有参数，支持默认参。<br>  1 仅有一个参数时，该函数即表示构造函数，又表示一种隐式转换，从而支持<code>CTest obj = 1</code>，可以使用关键字<code>explict</code>表示支持显示调用构造函数，不允许隐式转换。<br>  2 支持函数重载。<br>  3 如果不重载构造函数，编译器会提供一个无参的默认构造函数。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CTest() = <span class="keyword">default</span>;  <span class="comment">// 表示使用默认的构造函数</span></span><br><span class="line">CTest() = <span class="keyword">delete</span>;   <span class="comment">// 表示禁止使用某函数(删除</span></span><br></pre></td></tr></table></figure></li>
<li>构造函数可以使用初始化列表来初始化成员。  </li>
<li>构造函数通常不要手动调用。  </li>
</ul>
<h2 id="11-析构函数"><a href="#11-析构函数" class="headerlink" title="11 析构函数"></a>11 析构函数</h2><p><a href="https://www.bilibili.com/video/BV1jJ411279W" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>完成资源的反初始化。(释放资源  </li>
<li>在类名前加<code>~</code>。  </li>
<li>由编译器决定调用时机，不需要手动调用。  </li>
<li>不能有参数和返回值。  </li>
<li>不能重载。  </li>
</ul>
<h2 id="12-构造函数与析构函数的调用时机"><a href="#12-构造函数与析构函数的调用时机" class="headerlink" title="12 构造函数与析构函数的调用时机"></a>12 构造函数与析构函数的调用时机</h2><p><a href="https://www.bilibili.com/video/BV1jJ411279B" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>构造函数和析构函数需要时公有的。  </li>
<li>栈上的局部对象的调用时机:<br>  1 构造: 声明该对象时构造。<br>  2 析构: 对象出作用域时调用析构。  </li>
<li>全局对象(堆? no)的调用时机:<br>  1 构造: 进入到<code>main</code>函数之前。<br>  2 析构: 出<code>main</code>函数之后。  </li>
</ul>
<h2 id="13-拷贝构造函数"><a href="#13-拷贝构造函数" class="headerlink" title="13 拷贝构造函数"></a>13 拷贝构造函数</h2><p><a href="https://www.bilibili.com/video/BV17J41127Fr" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>作用: 本质上也是一种构造函数。  </li>
<li>调用时机: 当用一个对象创建另外一个对象时调用。<code>CTest t2 = t1;</code>  </li>
<li>缺省的拷贝构造函数的作用: 完全的把对象1拷贝给对象2。(<code>memcpy</code>  </li>
</ul>
<h2 id="14-浅拷贝与深拷贝"><a href="#14-浅拷贝与深拷贝" class="headerlink" title="14 浅拷贝与深拷贝"></a>14 浅拷贝与深拷贝</h2><p><a href="https://www.bilibili.com/video/BV1jJ41127Zt" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>缺省的拷贝构造函数中是浅拷贝。(类似两个指针指向同一个堆空间  </li>
<li>当对象中的成员函数存在一种需要分配的资源时(malloc)，为了避免在析构时重复释放，需要重写(深)拷贝构造函数或禁用拷贝构造函数。  </li>
</ul>
<h2 id="15-new与delete运算符"><a href="#15-new与delete运算符" class="headerlink" title="15 new与delete运算符"></a>15 <code>new</code>与<code>delete</code>运算符</h2><p><a href="https://www.bilibili.com/video/BV1jJ41127oW" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV17J41127Np" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li><code>new</code>分配空间，调用构造函数。  </li>
<li><code>delete</code>调用析构函数，释放空间。  </li>
<li><code>new</code>和<code>delete</code>都是在堆上分配和释放空间。  </li>
<li>相比于<code>C</code>的<code>malloc</code>和<code>free</code>，<code>new</code>与<code>delete</code>能够调用类的构造和析构函数。  </li>
<li>对于基本数据类型(相对于自定义的类对象)而言，<code>new</code>与<code>delete</code>仅仅分配或释放内存空间。(<code>int</code>， <code>float</code>，…  </li>
<li>当申请一个堆上的对象时，使用<code>new</code>和<code>delete</code>，不能使用<code>malloc</code>和<code>free</code>替换。  </li>
<li><code>new []</code>分配数组，<code>delete []</code>释放数组空间。    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CTest* pt = <span class="keyword">new</span> CTest[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] pt;</span><br></pre></td></tr></table></figure></li>
<li><code>new []</code>与<code>delete []</code>要配套使用，特别是申请对象数组时。  </li>
<li>vs编译器会在<code>new []</code>申请对象数组时，在堆开始的前4个字节写入当前数组的长度，用于记录<code>delete []</code>释放时，析构调用的次数。  </li>
</ul>
<h2 id="16-类的派生与继承"><a href="#16-类的派生与继承" class="headerlink" title="16 类的派生与继承"></a>16 类的派生与继承</h2><p><a href="https://www.bilibili.com/video/BV17J41127P7" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV17J41127AM" target="_blank" rel="noopener">链接_视频_2</a><br><a href="https://www.bilibili.com/video/BV17J41127wP" target="_blank" rel="noopener">链接_视频_3</a>  </p>
<ul>
<li>子类(派生类)，父类(基类)。  </li>
<li>保护成员(<code>protected</code>)除了自身或派生类以外，不能在其他类外使用。  </li>
<li>继承的可见性<table>
<thead>
<tr>
<th align="center">父类</th>
<th align="center">继承方式</th>
<th align="center">子类</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">公有继承(<code>public</code>)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">公有成员(<code>public</code>)</td>
<td align="center"></td>
<td align="center">公有成员(<code>public</code>)</td>
</tr>
<tr>
<td align="center">保护成员(<code>protected</code>)</td>
<td align="center"></td>
<td align="center">保护成员(<code>protected</code>)</td>
</tr>
<tr>
<td align="center">私有成员(<code>private</code>)</td>
<td align="center"></td>
<td align="center">不可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">保护继承(<code>protected</code>)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">公有成员(<code>public</code>)</td>
<td align="center"></td>
<td align="center">保护成员(<code>protected</code>)</td>
</tr>
<tr>
<td align="center">保护成员(<code>protected</code>)</td>
<td align="center"></td>
<td align="center">保护成员(<code>protected</code>)</td>
</tr>
<tr>
<td align="center">私有成员(<code>private</code>)</td>
<td align="center"></td>
<td align="center">不可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">私有继承(<code>private</code>)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">公有成员(<code>public</code>)</td>
<td align="center"></td>
<td align="center">私有成员(<code>private</code>)</td>
</tr>
<tr>
<td align="center">保护成员(<code>protected</code>)</td>
<td align="center"></td>
<td align="center">私有成员(<code>private</code>)</td>
</tr>
<tr>
<td align="center">私有成员(<code>private</code>)</td>
<td align="center"></td>
<td align="center">不可见</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li>继承的可见性是由编译器在编译时刻做的限制。  </li>
<li>子类指针转换为父类指针是安全的，父类指针转换为子类指针是不安全的。(数据成员个数问题，指针越界  </li>
</ul>
<h2 id="17-派生类中构造与析构顺序"><a href="#17-派生类中构造与析构顺序" class="headerlink" title="17 派生类中构造与析构顺序"></a>17 派生类中构造与析构顺序</h2><p><a href="https://www.bilibili.com/video/BV17J41127u1" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>派生类的构造顺序，先父类后子类。  </li>
<li>派生类的析构顺序，先子类后父类。  </li>
<li>成员类的构造顺序，先成员类后自己。  </li>
<li>成员类的析构顺序，先自己后成员类。  </li>
</ul>
<h2 id="18-初始化列表"><a href="#18-初始化列表" class="headerlink" title="18 初始化列表"></a>18 初始化列表</h2><p><a href="https://www.bilibili.com/video/BV17J41127gP" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>初始化列表作用:<br>  1 调用父类的有参构造。<br>  2 对于自身成员的初始化。<br>  3 对于常量成员的初始化。  </li>
</ul>
<h2 id="19-函数隐藏"><a href="#19-函数隐藏" class="headerlink" title="19 函数隐藏"></a>19 函数隐藏</h2><p><a href="https://www.bilibili.com/video/BV17J41127gP" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>函数隐藏的条件:<br>  1 作用域不同。(父类与子类<br>  2 函数名相同。<br>  3 参数列表，调用约定和返回值不考虑。  </li>
</ul>
<h2 id="20-多态与虚函数"><a href="#20-多态与虚函数" class="headerlink" title="20 多态与虚函数"></a>20 多态与虚函数</h2><p><a href="https://www.bilibili.com/video/BV17J41127uM" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1ZJ411t7xQ" target="_blank" rel="noopener">链接_视频_2</a><br><a href="https://www.bilibili.com/video/BV1gz41187UX" target="_blank" rel="noopener">链接_视频_3</a>  </p>
<ul>
<li>父类中使用<code>virtual</code>关键字将成员函数变为虚函数。  </li>
<li>虚函数的调用原理:<br>  1 虚函数的调用方法是间接调用，先查虚表地址，再查虚表中的虚函数指针。<br>  2 增加了虚函数<code>virtual</code>关键字的对象的头部4个字节是虚表地址。(单继承的情况下  </li>
</ul>
<h2 id="21-函数覆盖-虚函数"><a href="#21-函数覆盖-虚函数" class="headerlink" title="21 函数覆盖 (虚函数"></a>21 函数覆盖 (虚函数</h2><p><a href="https://www.bilibili.com/video/BV1Ez411q7Ue" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1Mg4y167VM" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li>函数覆盖的条件:<br>  1 作用域不同。(父子类之间继承关系<br>  2 函数名，参数列表(参数的个数，顺序，类型)，返回值，调用约定(<code>__thiscall</code>)必须相同。<br>  3 有<code>virtual</code>关键字。  </li>
<li>虚表大小的确定:<br>  1 由编译器在编译时期确定的。<br>  2 在运行时的内存中并没有个数的表示。  </li>
<li>虚表中虚函数的顺序:<br>  1 子类继承父类的所有的虚函数。(公有<br>  2 父类的虚函数顺序决定了子类虚函数的顺序。<br>  3 子类重写了父类的某虚函数，则会在子类自己的虚表中覆盖对应位置的函数。<br>  4 子类未重写某虚函数，则直接继承父类的该虚函数。<br>  5 子类自己的虚函会出现在自己虚表中父类所定义的虚函数后面。  </li>
</ul>
<h2 id="22-虚函数的调用方式"><a href="#22-虚函数的调用方式" class="headerlink" title="22 虚函数的调用方式"></a>22 虚函数的调用方式</h2><p><a href="https://www.bilibili.com/video/BV1n54y1X76T" target="_blank" rel="noopener">链接_视频</a>  </p>
<ul>
<li>直接调用指根据函数名称，直接调用该函数。(编译器在编译时就确定了<br>  1 普通函数的调用。<br>  2 对象的普通成员函数(相对与虚函数而言)的调用。<br>  3 对象的虚函数的调用。  </li>
<li>间接调用(虚调用，即通过查虚表来调用)指通过查找对象的虚表下表来调用函数的方法。(在运行时期确定调用谁<br>  1 通过对象的指针调用虚函数。<br>  2 通过对象的引用调用虚函数。  </li>
</ul>
<h2 id="23-函数覆盖重载隐藏的调用秘笈"><a href="#23-函数覆盖重载隐藏的调用秘笈" class="headerlink" title="23 函数覆盖重载隐藏的调用秘笈"></a>23 函数覆盖重载隐藏的调用秘笈</h2><p><a href="https://www.bilibili.com/video/BV1sA411t7pq" target="_blank" rel="noopener">链接_视频_1</a><br><a href="https://www.bilibili.com/video/BV1Fe411W7p5" target="_blank" rel="noopener">链接_视频_2</a>  </p>
<ul>
<li>讲的太TM细了，高手 !!!  </li>
<li>调用者的类型决定查找的起点:  <ul>
<li>1 在调用者的类中，查找同名函数:<br>  1.1 如果没有，则往上一层查找，如果均找不到，则报错。(未定义<br>  1.2 如果有，则不会往上面查找，可见的域就是当前找到的同名函数所在的域。(函数隐藏  </li>
<li>2 在当前可见的域中，找到最佳函数。(函数重载规则<br>  2.1 如果唯一的最佳函数不是虚函数，则该调用是直接调用。<br>  2.2 如果唯一的最佳函数虚函数，判断调用者是否是指针或引用:  <pre><code>2.2.1 调用者是指针或引用，则是间接调用。(函数覆盖规则  
2.2.2 调用者不是指针或引用，则是直接调用。  </code></pre></li>
</ul>
</li>
<li>直接调用: 谁的类型调谁。  </li>
<li>间接调用: 谁的虚表调谁。  </li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_工厂模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-参考链接"><a href="#0-参考链接" class="headerlink" title="0 参考链接"></a>0 参考链接</h2><p><a href="https://www.bilibili.com/video/BV1e54y1X7bE?from=search&seid=16085648626900326892" target="_blank" rel="noopener">链接_视频</a><br><a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">链接_文档</a>  </p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>工厂模式，Factory Pattern。  </p>
<a id="more"></a>  

<p><code>意图：</code>创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来只当新创建对象。定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><code>主要解决：</code>接口选择的问题。<br><code>何时使用：</code>我们明确地计划不同条件下创建不同实例时。<br><code>如何解决：</code>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><code>关键代码：</code>创建过程在其子类执行。<br><code>优点：</code>  </p>
<ul>
<li>调用者想创建一个对象，只要知道其名称即可。  </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类即可。  </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。  </li>
</ul>
<p><code>使用场景：</code>  </p>
<ul>
<li>日志记录器，记录可能记录到本地硬盘，系统事件或远程服务器等，用户可以选择记录日志到什么地方。  </li>
<li>设计一个连接服务器的框架，需要三个协议，<code>POP3</code>，<code>IMAP</code>和<code>HTTP</code>，可以把三个作为产品类，共同实现一个接口。  </li>
</ul>
<p><code>Highlight：</code>  </p>
<ul>
<li>创建复杂对象适合使用工厂模式，而简单对象，特别是只需要通过<code>new</code>就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，增加系统的复杂度。(<code>So, what is 复杂对象 ??</code>)  </li>
</ul>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><h3 id="2-0-case-0-子类数据成员一致"><a href="#2-0-case-0-子类数据成员一致" class="headerlink" title="2.0 case_0: 子类数据成员一致"></a>2.0 case_0: 子类数据成员<code>一致</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类Color，接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字virtual修饰，虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Red继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Red"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Green继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Green"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类，生成对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字static修饰，定位为类的静态方法，调用时不需要有类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Color* <span class="title">getColor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">"Red"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="string">"Green"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pRed</span><span class="params">(Factory::getColor(<span class="string">"Red"</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pGreen</span><span class="params">(Factory::getColor(<span class="string">"Green"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRed != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pRed-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pGreen != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pGreen-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-case-1-子类数据成员不一致"><a href="#2-1-case-1-子类数据成员不一致" class="headerlink" title="2.1 case_1: 子类数据成员不一致"></a>2.1 case_1: 子类数据成员<code>不一致</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类Color，接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键字virtual修饰，虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Red继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Red(<span class="built_in">std</span>::<span class="built_in">string</span> a, <span class="keyword">int</span> b)</span><br><span class="line">        : a_(<span class="built_in">std</span>::<span class="built_in">move</span>(a)), b_(b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ &lt;&lt; <span class="string">", "</span> &lt;&lt; b_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Green继承父类Color</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span> :</span> <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Green(<span class="built_in">std</span>::<span class="built_in">string</span> a)</span><br><span class="line">        : a_(<span class="built_in">std</span>::<span class="built_in">move</span>(a)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字override修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂不一定需要是类，一个函数也可以</span></span><br><span class="line"><span class="comment">// 泛型，模板</span></span><br><span class="line"><span class="comment">// 参数个数不定, typename ... Args可变参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Object, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">Color* <span class="title">factoryColor</span><span class="params">(<span class="keyword">typename</span> ... Args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(args ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pRed</span><span class="params">(factoryColor(<span class="string">"Red"</span>, <span class="number">666</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Color&gt; <span class="title">pGreen</span><span class="params">(factoryColor(<span class="string">"Green"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRed != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pRed-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pGreen != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pGreen-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><p><code>设计模式</code> (<code>Design Pattern</code>) 代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用。<br>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，是众多软件开发人员经过相当长一段时间的试验和错误总结出来的。<br>设计模式是一套被反复使用的，多数人知晓的，经过分类编目的，代码设计经验的总结。<br>使用设计模式是为了重用代码，让代码更容易被他人理解，保证代码可靠性。  </p>
<a id="more"></a>

<h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h2><h3 id="1-0-创建型模式-Creational-Patterns"><a href="#1-0-创建型模式-Creational-Patterns" class="headerlink" title="1.0 创建型模式 (Creational Patterns)"></a>1.0 创建型模式 (Creational Patterns)</h3><p>这是设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用<code>new</code>运算符实例化对象。这使得程序在判断针对某个给定实例需要创建哪个对象时更加灵活。  </p>
<ul>
<li>工厂模式 (Factory Pattern)  </li>
<li>抽象工厂模式 (Abstract Factory Pattern)  </li>
<li>单例模式 (Singleton Pattern)  </li>
<li>建造者模式 (Builder Pattern)  </li>
<li>原型模式 (Prototype Pattern)  </li>
</ul>
<h3 id="1-1-结构性模式"><a href="#1-1-结构性模式" class="headerlink" title="1.1 结构性模式"></a>1.1 结构性模式</h3><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。  </p>
<ul>
<li>适配器模式 (Adapter Pattern)  </li>
<li>桥接模式 (Bridge Pattern)  </li>
<li>过滤器模式 (Filter, Criteria Pattern)  </li>
<li>组合模式 (Composite Pattern)  </li>
<li>装饰器模式 (Decorator Pattern)  </li>
<li>外观模式 (Facade Pattern)  </li>
<li>享元模式 (Flyweight Pattern)  </li>
<li>代理模式 (Proxy Pattern)  </li>
</ul>
<h3 id="1-2-行为型模式"><a href="#1-2-行为型模式" class="headerlink" title="1.2 行为型模式"></a>1.2 行为型模式</h3><p>这些设计模式特别关注对象之间的通信。  </p>
<ul>
<li>责任链模式 (Chain of Responsibility Pattern)  </li>
<li>命令模式 (Command Pattern)  </li>
<li>解释器模式 (Interpreter Pattern)  </li>
<li>迭代器模式 (Iterator Pattern)  </li>
<li>中介者模式 (Mediator Pattern)  </li>
<li>备忘录模式 (Memento Pattern)  </li>
<li>观察者模式 (Observer Pattern)  </li>
<li>状态模式 (State Pattern)  </li>
<li>空对象模式 (Null Object Pattern)  </li>
<li>策略模式 (Strategy Pattern)  </li>
<li>模板模式 (Template Pattern)  </li>
<li>访问者模式 (Visitor Pattern)  </li>
</ul>
<h3 id="1-3-J2EE模式"><a href="#1-3-J2EE模式" class="headerlink" title="1.3 J2EE模式"></a>1.3 J2EE模式</h3><p>这些设计模式特别关注表示层。  </p>
<ul>
<li>MVC 模式 (MVC Pattern)  </li>
<li>业务代表模式 (Business Delegate Pattern)  </li>
<li>组合实体模式 (Composite Entity Pattern)  </li>
<li>数据访问对象模式 (Data Access Object Pattern)  </li>
<li>前端控制器模式 (Front Controller Pattern)  </li>
<li>拦截过滤器模式 (Intercepting Filter Pattern)  </li>
<li>服务定位器模式 (Service Locator Pattern)  </li>
<li>传输对象模式 (Transfer Object Pattern)  </li>
</ul>
<h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2 原则"></a>2 原则</h2><h3 id="2-0-开闭原则-Open-Close-Principle"><a href="#2-0-开闭原则-Open-Close-Principle" class="headerlink" title="2.0 开闭原则 (Open Close Principle)"></a>2.0 开闭原则 (Open Close Principle)</h3><p>对<code>扩展开放，对修改关闭</code>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </p>
<h3 id="2-1-里氏代换原则-Liskov-Substitution-Principle"><a href="#2-1-里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="2.1 里氏代换原则 (Liskov Substitution Principle)"></a>2.1 里氏代换原则 (Liskov Substitution Principle)</h3><p>任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </p>
<h3 id="2-2-依赖倒转原则-Dependence-Inversion-Principle"><a href="#2-2-依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="2.2 依赖倒转原则 (Dependence Inversion Principle)"></a>2.2 依赖倒转原则 (Dependence Inversion Principle)</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </p>
<h3 id="2-3-接口隔离原则-Interface-Segregation-Principle"><a href="#2-3-接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="2.3 接口隔离原则 (Interface Segregation Principle)"></a>2.3 接口隔离原则 (Interface Segregation Principle)</h3><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </p>
<h3 id="2-4-迪米特法则，又称最少知道原则-Demeter-Principle"><a href="#2-4-迪米特法则，又称最少知道原则-Demeter-Principle" class="headerlink" title="2.4 迪米特法则，又称最少知道原则 (Demeter Principle)"></a>2.4 迪米特法则，又称最少知道原则 (Demeter Principle)</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。  </p>
<h3 id="2-5-合成复用原则-Composite-Reuse-Principle"><a href="#2-5-合成复用原则-Composite-Reuse-Principle" class="headerlink" title="2.5 合成复用原则 (Composite Reuse Principle)"></a>2.5 合成复用原则 (Composite Reuse Principle)</h3><p>尽量使用合成/聚合的方式，而不是使用继承。  </p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式_单例模式</title>
    <url>/2020/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-参考链接"><a href="#0-参考链接" class="headerlink" title="0 参考链接"></a>0 参考链接</h2><p><a href="https://www.bilibili.com/video/BV1Gz4y1d7RJ?from=search&seid=16674851411794252260" target="_blank" rel="noopener">链接_视频</a><br><a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">链接_文档</a>  </p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>单例模式，Singleton Pattern。  </p>
<a id="more"></a>  

<p><code>意图：</code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><code>主要解决：</code>一个全局使用的类频繁地创建与销毁。<br><code>何时使用：</code>需要控制实例数目，节省系统资源的时候。<br><code>如何解决：</code>判断系统是否已经有这个单例，如果有则返回，如果无则创建。<br><code>关键代码：</code>构造函数是私有的。<br><code>优点：</code>  </p>
<ul>
<li>在内存中只有一个实例，减少了内存开销，尤其是频繁的创建和销毁实例。  </li>
<li>避免对资源的多重占用。（比如写文件操作）  </li>
</ul>
<p><code>使用场景：</code>  </p>
<ul>
<li>要求生产唯一序列号。  </li>
<li>创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等。</li>
<li>日志类。  </li>
</ul>
<p><code>Highlight：</code></p>
<ul>
<li>单例类只能有一个实例。  </li>
<li>单例类必须自己创建自己的唯一实例。  </li>
<li>单例类必须给所有其他对象提供这一实例 <code>?</code>  </li>
<li>指针<code>*</code>存在线程安全问题，以下实现使用引用<code>&amp;</code>的方式。  </li>
</ul>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singletom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton() destruct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象的唯一的用户接口</span></span><br><span class="line">    <span class="comment">// static修饰符，使其与类无关</span></span><br><span class="line">    <span class="comment">// 返回引用&amp;，而不是指针*</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">CreateObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建static对象</span></span><br><span class="line">        <span class="keyword">static</span> Singletom obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// 使用delete，禁用拷贝构造</span></span><br><span class="line">    Singleton(Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// = 运算符重载</span></span><br><span class="line">    <span class="comment">// Singleton* operator= (Singleton&amp; obj) = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="comment">// 构造函数私有化</span></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton() construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Option_A</span></span><br><span class="line">    <span class="comment">// 同时还要限制其拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数私有化</span></span><br><span class="line">    <span class="comment">// Singleton(Singleton&amp; obj) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; "Singleton(Singleton&amp; obj) construct" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用引用来接函数返回值</span></span><br><span class="line">    <span class="comment">// 因为方法是static，所以使用 类名::函数名 方式调用</span></span><br><span class="line">    <span class="comment">// pObj1和pObj2是同一个实例（同一块内存）</span></span><br><span class="line">    Singletom&amp; pObj1 = Singletom::CreateObject();</span><br><span class="line">    Singletom&amp; pObj2 = Singletom::CreateObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200627</title>
    <url>/2020/06/27/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200627/</url>
    <content><![CDATA[<p>六月的上海是淅淅沥沥不停的雨天，为这偌大的城市增添几分烟雨朦胧的隐秘感。  </p>
<p>端午节小假期就要结束了，自然醒洗漱后的上午，打开窗户，呼吸着湿润的新鲜空气，隔着耳机听着滴答的雨声。安静下来，整理下近些日子的心情吧。<br>如同往常，心中能有希望坐下来记录些什么的冲动，必定是因为丧到了一定程度。所以接下来的内容必定会略显消极悲观，但却是对生活的真实认知与感受。<br><code>请选择性阅读，不接受指点评论。</code>  </p>
<a id="more"></a>  

<p>从老妈生病开始吧。为什么生活总是选择欺负最善良无助的人？和大多数农村家庭主妇一样，老妈没有念过大学，没有过人的天资，没有很高的远见，没有科学的教育培养孩子的方法。但她是如此的勤勤恳恳，任劳任怨，朴素节俭，这些词都太过于轻描淡写不足以形容。世上的甘甜有七分，您却只尝了三分；世上的苦难有三分，您缺尝了七分。老姐好心带老妈去医院体检身体，查找常年低质量睡眠的病因，大夫开了中药帮助调理身体，可万万没想到中药却引起了更加严重的急性肝损伤，并导致黄疸。老妈病黄消瘦的面庞，异常高的吓人的血常规指标，无一不使人担忧至极。  </p>
<p>生活又放过了谁呢，每个人不都正在经历苦难吗？有人因为连续的考研失败而变得抑郁，有人还在因为没有小论文无法按期拿到毕业和学位证而苦恼，有人已经毕业了却还未能拿到相对满意的工作offer，有人失去了亲人生活崩塌性破碎…。幸福的人总是相似的，不幸的人各有各的不幸。生活本是如此，不如意十有八九。等它们都过去了，就变成了一个个故事。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200510</title>
    <url>/2020/05/10/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200510/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>丢掉学生的标签成为社会人已经有一段时间了，入职了校招时曾经引以为豪的商汤科技。既然使用<code>曾经</code>来形容，便意味着这些日子并不是十分如意。  </p>
  <a id="more"></a>  

<p>直到如今，关于职业与理想也并没有很清晰的规划。大四专业实习在武汉做外业测量，工作内容是施工基坑和周围建筑物的沉降变形监测，化身为名副其实的跑杆神童，如果非要总结实习收获，便只能是掌握了各种扶尺姿势，这种和专科生混在一起的工作怎么能对得起自命不凡的性格。获得保研资格后，甚至还曾为武大老师开出的<code>10W+</code>的年薪动摇读研的想法，公司做三维扫描仪研发，相比于外业测量工作已提升了一个Level，无论如何，现在看来当时的抉择也是正确的。选择导师时，由于夏令营成绩排名靠后，而被林老师推给叶老师，专业从遥感转为摄影测量，在入学后，又误打误撞地入了<code>SLAM</code>的坑，算是半脚踏入了互联网行业。受助于春红的内推，有幸能够去<code>Momenta</code>实习，并遇到了如此Nice的Mentor海瑞，提升了自身能力，认识了<code>自动驾驶</code>。相对可观的薪资，公司的工作研发氛围，和在校期间不开心等因素混杂在一起，成了继续求学道路上的巨大阻碍，并最终放弃了读博的梦想。人生的轨迹被无数的随机和选择排列组合着，没有明确的通行指示标志，反倒是像一张密密麻麻的由数不清的立交，隧道、匝口编织成的迷魂阵。  </p>
<p>入职前被告知被安排到系统组，而不是本该的地图定位组，Title从算法研发工程师转为系统开发工程师，入职后更是发现做的工作连自动驾驶都谈不上，而是<code>ADAS</code>相关，这和心心念的<code>定位算法研发</code>产生巨大落差，同时带来的是无数的思考与质问。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily Work</title>
    <url>/2020/05/07/daily_work/daily_work/</url>
    <content><![CDATA[<blockquote>
<p>工作学习生活记录  </p>
</blockquote>
<a id="more"></a>  

<h1 id="2020-05-08"><a href="#2020-05-08" class="headerlink" title="2020.05.08"></a>2020.05.08</h1><h2 id="1-Markdown教程"><a href="#1-Markdown教程" class="headerlink" title="1 Markdown教程"></a>1 Markdown教程</h2><p>为了使这份Daily Work记录文档更加优美实用，Markdown语法<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">教程</a>呈上！  </p>
<h3 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h3><p>使用<code>=</code>和<code>-</code>标记一级和二级标题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>
<p>使用<code>#</code>标记1-6级标题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<h3 id="1-2-段落格式"><a href="#1-2-段落格式" class="headerlink" title="1.2 段落格式"></a>1.2 段落格式</h3><h4 id="1-2-1-段落"><a href="#1-2-1-段落" class="headerlink" title="1.2.1 段落"></a>1.2.1 段落</h4><p>段落换行可以使用两个空格+回车，也可以使用一个空行。  </p>
<h4 id="1-2-2-字体"><a href="#1-2-2-字体" class="headerlink" title="1.2.2 字体"></a>1.2.2 字体</h4><p>特殊字体包括斜体、粗体和粗斜体三种。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-分割线"><a href="#1-2-3-分割线" class="headerlink" title="1.2.3 分割线"></a>1.2.3 分割线</h4><p>使用三个以上的<code>*</code>或<code>-</code>，建立分割线，行内不能有其他东西。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-删除线"><a href="#1-2-4-删除线" class="headerlink" title="1.2.4 删除线"></a>1.2.4 删除线</h4><p>在文本的两端加上两个<code>~~</code>，实现在文本上添加删除线。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~文本~~</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-下划线"><a href="#1-2-5-下划线" class="headerlink" title="1.2.5 下划线"></a>1.2.5 下划线</h4><p>在文本的两端加上<code>&lt;/u&gt;</code>，实现在文本下方添加下划线。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;u&gt;文本&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-脚注"><a href="#1-2-6-脚注" class="headerlink" title="1.2.6 脚注"></a>1.2.6 脚注</h4><p>使用<code>[^脚注]</code>的方式为文本添加脚注，注意脚注标示的一致对应。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本[^脚注1]</span><br><span class="line">[^脚注1]: 脚注内容</span><br></pre></td></tr></table></figure>
<h3 id="1-3-列表"><a href="#1-3-列表" class="headerlink" title="1.3 列表"></a>1.3 列表</h3><p>无序列表使用<code>*</code>或<code>+</code>或<code>-</code>标记，有序列表使用<code>数字.</code>标记。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line"></span><br><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure>
<h3 id="1-4-区块"><a href="#1-4-区块" class="headerlink" title="1.4 区块"></a>1.4 区块</h3><p>引用是在段落开头使用<code>&gt;</code>标记。区块是可以嵌套的，一个<code>&gt;</code>是最外层，两个<code>&gt;&gt;</code>是第一层嵌套，以此类推。此外，区块和列表可相互嵌套，自由发挥。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure>
<h3 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5 代码"></a>1.5 代码</h3><p>函数可以使用反引号<code>``</code>包括。单独的代码段可以使用<code>``` bash</code>包括，语言根据实际情况更换，添加语言标示，能够自动地更加美观的颜色显示代码。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;函数&#96;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line">代码段</span><br><span class="line">&#96;&#96;&#96;                                                                  .</span><br></pre></td></tr></table></figure>
<h3 id="1-6-链接"><a href="#1-6-链接" class="headerlink" title="1.6 链接"></a>1.6 链接</h3><p>根据是否显式地显示网址，可以有两种添加链接的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-图片"><a href="#1-7-图片" class="headerlink" title="1.7 图片"></a>1.7 图片</h3><p>图片地址可以是网址，也可以是目录路径。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>
<p>Markdown无法制定图片的高度与宽度，如有需要，可使用普通的<code>&lt;img&gt;</code>标签。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;图片地址&quot; width&#x3D;&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-表格"><a href="#1-8-表格" class="headerlink" title="1.8 表格"></a>1.8 表格</h3><p>制作表格使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头与其他行。<code>:-</code>左对齐，<code>-:</code>右对齐，<code>:-:</code>居中对齐。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>


<h2 id="2-NFS配置与使用"><a href="#2-NFS配置与使用" class="headerlink" title="2 NFS配置与使用"></a>2 <code>NFS</code>配置与使用</h2><p><code>NFS</code>服务中需要有两台机器，一台作为<code>NFS Serve</code>，另一台作为<code>NFS Client</code>。参考<a href="https://blog.csdn.net/zpf336/article/details/50825847" target="_blank" rel="noopener">链接</a>。  </p>
<h3 id="2-1-NFS-Serve"><a href="#2-1-NFS-Serve" class="headerlink" title="2.1 NFS Serve"></a>2.1 <code>NFS Serve</code></h3><p>安装<code>nfs-server</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y nfs-server</span><br></pre></td></tr></table></figure>
<p>创建将被分享的文件夹，即被<code>NFS Client</code> mount的文件夹。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/liuhang/share</span><br></pre></td></tr></table></figure>
<p>配置<code>NFS Serve</code>，修改<code>/etc/exports</code>文件，在最后一行添加：<code>/home/liuhang/share ${ip}(rw, sync, no_root_squash)</code>，其中<code>${ip}</code>是指能够访问该共享文件夹的<code>NFS Client</code>的ip。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure>
<p>启动<code>NFS</code>服务。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nfs-server start</span><br><span class="line">sudo service nfs-server restart</span><br></pre></td></tr></table></figure>
<h3 id="2-2-NFS-Client"><a href="#2-2-NFS-Client" class="headerlink" title="2.2 NFS Client"></a>2.2 <code>NFS Client</code></h3><p>安装<code>nfs-common</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure>
<p>在<code>NFS Client</code>本地目录中创建新文件夹，并挂载<code>NFS Server</code>的共享文件夹。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ./new_folder/</span><br><span class="line">chmod -R 777 ./new_folder/</span><br><span class="line">mount -o nolock -t nfs <span class="variable">$&#123;NFS Server ip&#125;</span>:/home/liuhang/share ./new_folder</span><br></pre></td></tr></table></figure>
<p>至此即可以在<code>NFS Client</code>访问<code>NFS Server</code>的共享文件夹，进行文件的读写。  </p>
<h1 id="2020-05-09"><a href="#2020-05-09" class="headerlink" title="2020.05.09"></a>2020.05.09</h1><h2 id="1-Amba平台JDK与JNLP安装"><a href="#1-Amba平台JDK与JNLP安装" class="headerlink" title="1 Amba平台JDK与JNLP安装"></a>1 Amba平台JDK与JNLP安装</h2><p><a href="https://blog.csdn.net/u012417380/article/details/72809590" target="_blank" rel="noopener">Ubuntu下JDK的安装与环境配置</a><br><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">JDK下载</a><br><a href="https://www.cnblogs.com/tiandi/p/11317083.html" target="_blank" rel="noopener">Linux中环境变量和系统加载环境变量的顺序</a>  </p>
<h2 id="2-Jenkins环境配置"><a href="#2-Jenkins环境配置" class="headerlink" title="2 Jenkins环境配置"></a>2 Jenkins环境配置</h2><p><a href="https://zhuanlan.zhihu.com/p/79027031" target="_blank" rel="noopener">Jenkins环境配置篇–增加节点</a><br><a href="http://www.mamicode.com/info-detail-2395829.html" target="_blank" rel="noopener">Jenkins构建多节点之Linux节点</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>SVN服务器搭建与使用</title>
    <url>/2020/05/02/%E6%95%99%E7%A8%8B/SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>SVN(subversion)是一个开放源代码的版本控制系统  </p>
</blockquote>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="1-安装-svn"><a href="#1-安装-svn" class="headerlink" title="1 安装 svn"></a>1 安装 svn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install subversion</span><br></pre></td></tr></table></figure>

<h3 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2 创建仓库"></a>2 创建仓库</h3><p>在指定的文件夹下创建新的仓库(repository)。 如在 <code>/data/svn</code> 文件夹下创建名为 <code>repo</code> 的仓库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /data/svn</span><br><span class="line">$ mkdir repo</span><br><span class="line">$ svnadmin create /data/svn/repo</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<p>创建完成后，在 <code>/data/svn/repo</code> 文件夹中会有相关文件：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ll ./repo</span><br><span class="line">total 32</span><br><span class="line">drwxrwxr-x 6 ** ** 4096 4月  26 09:50 ./</span><br><span class="line">drwxr-xr-x 5 ** ** 4096 4月  26 09:50 ../</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 conf/</span><br><span class="line">drwxrwsr-x 6 ** ** 4096 4月  26 09:50 db/</span><br><span class="line">-r--r--r-- 1 ** **    2 4月  26 09:50 format</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 hooks/</span><br><span class="line">drwxrwxr-x 2 ** ** 4096 4月  26 09:50 locks/</span><br><span class="line">-rw-rw-r-- 1 ** **  246 4月  26 09:50 README.txt</span><br></pre></td></tr></table></figure>

<h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3 修改配置"></a>3 修改配置</h3><p>在生成的文件中，<code>conf</code> 文件夹是用来存放配置文件的，其中 <code>passwd</code> 是账号密码文件，<code>authz</code> 是权限控制文件，<code>svnserve.conf</code>是svn服务配置文件。  </p>
<h4 id="3-1-配置-passwd"><a href="#3-1-配置-passwd" class="headerlink" title="3.1 配置 passwd"></a>3.1 配置 <code>passwd</code></h4><p>添加新用户与密码。如 <code>leo = 123789</code>，创建了用户 <code>leo</code>，密码为 <code>123789</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line"><span class="comment"># harry = harryssecret</span></span><br><span class="line"><span class="comment"># sally = sallyssecret</span></span><br><span class="line"></span><br><span class="line">leo = 123789</span><br></pre></td></tr></table></figure>
<h4 id="3-2-配置-authz"><a href="#3-2-配置-authz" class="headerlink" title="3.2 配置 authz"></a>3.2 配置 <code>authz</code></h4><p>为新加的用户添加文件读写权限，<code>r</code> 表示读权限，<code>w</code> 表示写权限，<code>rw</code>表示读写权限，此处添加的读写权限包括仓库 <code>/data/svn/repo/</code> 中的所有文件，。如 <code>leo = rw</code> 表示为用户 <code>leo</code> 添加读写权限，<code>* =</code> 表示其他用户无任何权限，注意前置符 <code>[/]</code> 不可省略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[/]</span><br><span class="line">leo = rw</span><br><span class="line">* =</span><br></pre></td></tr></table></figure>
<p>如果需要对用户进行分组批量管理权限，可以使用 <code>[groups]</code> 标签。如下配置中创建了 <code>groups1</code> 和 <code>groups2</code>分组，并为两个分组设置不同的权限，注意组内的多个用户使用 <code>,</code> 隔开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[groups]</span><br><span class="line">groups1 = leo, john</span><br><span class="line">groups2 = lily</span><br><span class="line">[/]</span><br><span class="line">@groups1 = rw</span><br><span class="line">@groups2 = r</span><br><span class="line">* =</span><br></pre></td></tr></table></figure>
<h4 id="3-3-配置-svnserve-conf"><a href="#3-3-配置-svnserve-conf" class="headerlink" title="3.3 配置 svnserve.conf"></a>3.3 配置 <code>svnserve.conf</code></h4><p>打开以下4个注释，注意打开注释时前面不要留有空格，否则访问库会报错。注意 <code>anon-access</code> 需改为 <code>none</code>, 否则 <code>svn log</code> 无法使用，why ?!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anon-access = none   <span class="comment"># 匿名用户无权限</span></span><br><span class="line">auth-access = write   <span class="comment"># 授权用户可写</span></span><br><span class="line">password-db = passwd   <span class="comment"># 指定账号文件</span></span><br><span class="line">authz-db = authz   <span class="comment"># 指定权限文件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4 启动服务"></a>4 启动服务</h3><p>配置完成后，可启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svnserve -d -r /data/svn/</span><br></pre></td></tr></table></figure>
<p>其中 <code>-d</code> 表示已守护模式启动，<code>-r</code> 表示指定svn版本库的根目录，便于客户端不用输入全路径就可以访问版本库。服务器默认使用 <code>3690</code> 端口号，若要使用非默认端口，可在启动命令后加 <code>--listen-port ××××</code>， 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ svnserve -d -r &#x2F;data&#x2F;svn&#x2F; --listen-port 3691</span><br></pre></td></tr></table></figure>
<p>启动后，可检查是否启动成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep svnserve</span><br><span class="line">senseti+ 12899  0.0  0.0  80556   948 ?        Ss   10:54   0:00 svnserve -d -r /data/svn</span><br><span class="line">senseti+ 12903  0.0  0.0  21292   984 pts/2    S+   10:55   0:00 grep --color=auto svnserve</span><br></pre></td></tr></table></figure>

<h3 id="5-关闭服务"><a href="#5-关闭服务" class="headerlink" title="5 关闭服务"></a>5 关闭服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ killall svnserve</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="1-安装-svn-1"><a href="#1-安装-svn-1" class="headerlink" title="1 安装 svn"></a>1 安装 svn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install subversion</span><br></pre></td></tr></table></figure>

<h3 id="2-提取操作"><a href="#2-提取操作" class="headerlink" title="2 提取操作"></a>2 提取操作</h3><p>在服务器启动服务后，可在客户端提取版本库文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn checkout svn://服务器ip/仓库名</span><br></pre></td></tr></table></figure>
<p>在执行提取命令后，将提示输入用户名和密码信息，提取的仓库文件保存在当前文件目录下。</p>
<h3 id="3-提交操作"><a href="#3-提交操作" class="headerlink" title="3 提交操作"></a>3 提交操作</h3><p>在提取版本库中增添或修改新的文件后，可提交至服务器版本库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn add 新增文件</span><br><span class="line">$ svn commit -m <span class="string">"提交信息"</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>commit</code> 命令后可跟文件名，仅提交指定的文件。</p>
<h3 id="4-提示！！"><a href="#4-提示！！" class="headerlink" title="4 提示！！"></a>4 提示！！</h3><p>对于新建的仓库，为了规范仓库管理，建立checkout到本地副本后，在仓库中创建 <code>trunk</code>, <code>branches</code> 和 <code>tags</code>三个文件夹，其中 <code>trunk</code> 存放主分支，<code>branches</code> 存放开发分支，<code>tags</code> 存放标签。  </p>
<hr>
<h2 id="更多常用命令"><a href="#更多常用命令" class="headerlink" title="更多常用命令"></a>更多常用命令</h2><h3 id="1-帮助"><a href="#1-帮助" class="headerlink" title="1 帮助"></a>1 帮助</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn <span class="built_in">help</span>   <span class="comment"># 查看svn所有子命令(subcommands)</span></span><br><span class="line">$ svn <span class="built_in">help</span> &lt;subcommands&gt;   <span class="comment"># 查看某个子命令的使用方法</span></span><br></pre></td></tr></table></figure>

<h3 id="2-添加文件到版本控制"><a href="#2-添加文件到版本控制" class="headerlink" title="2 添加文件到版本控制"></a>2 添加文件到版本控制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn add 文件名   <span class="comment"># 添加一个文件</span></span><br><span class="line">$ svn add 文件夹名   <span class="comment"># 添加一个文件夹中所有未添加的文件</span></span><br><span class="line">$ svn add 文件夹名 --non-recursive   <span class="comment"># 仅添加本文件夹，不添加文件夹中的内容</span></span><br><span class="line">$ svn add *   <span class="comment"># 添加s所有的文件(文件夹已经添加进去的不在进行操作)</span></span><br><span class="line">$ svn add * --force   <span class="comment"># 添加所有的文件(文件夹已经添加进去的也要再进行操作)</span></span><br><span class="line">$ svn add . --no-ignore --force   <span class="comment"># 添加当前目录下所有未添加的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="3-查看信息"><a href="#3-查看信息" class="headerlink" title="3 查看信息"></a>3 查看信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn status    <span class="comment"># 查看文件修改</span></span><br><span class="line">$ svn <span class="built_in">log</span> -r 2:3   <span class="comment"># 查看版本2和3之间的信息(版本作者、日期、路径等)</span></span><br><span class="line">$ svn <span class="built_in">log</span> 文件名   <span class="comment"># 查看某个文件的版本修改信息</span></span><br><span class="line">$ svn <span class="built_in">log</span> -l N -v   <span class="comment"># 查看限定N条记录的目录信息</span></span><br><span class="line">$ svn diff   <span class="comment"># 比较工作文件与缓存在.svn的原始拷贝</span></span><br><span class="line">$ svn diff -r 3 文件名   <span class="comment"># 比较工作拷贝和版本库中版本号为3的文件</span></span><br><span class="line">$ svn diff -r 2:3 文件名   <span class="comment"># 比较版本2和3的文件</span></span><br><span class="line">$ svn cat -r 版本号 文件名   <span class="comment"># 查看该版本号下该文件的内容</span></span><br><span class="line">$ svn list svn://服务器ip/版本库名   <span class="comment"># 在不下载文件到本地目录的情况下查看目录中的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-分支使用"><a href="#4-分支使用" class="headerlink" title="4 分支使用"></a>4 分支使用</h3><p>将trunk主分支内容copy至新建分支my_branch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn copy trunk/ branches/my_branch</span><br></pre></td></tr></table></figure>
<p>切换到新建分支进行开发，开发完成后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commit -m <span class="string">"update my_branch"</span></span><br></pre></td></tr></table></figure>
<p>切换至trunck分支，进行分支合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn update</span><br><span class="line">$ svn merge ../branches/my_branch</span><br></pre></td></tr></table></figure>
<p>把合并好后的trunk提交到版本库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commmit -m <span class="string">"update trunk"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-标签使用"><a href="#5-标签使用" class="headerlink" title="5 标签使用"></a>5 标签使用</h3><p>在本地工作副本中创建一个tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn copy trunk/ tags/v1.0</span><br></pre></td></tr></table></figure>
<p>提交tag内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ svn commit -m <span class="string">"tag v1.0"</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/svn/svn-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/svn/svn-tutorial.html</a>  </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200405</title>
    <url>/2020/04/05/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200405/</url>
    <content><![CDATA[<blockquote>
<p>青春逢盛世，奋斗正当时——做爱国主义的坚定弘扬者和践行者  </p>
</blockquote>
<p>春暖花开，疫情的阴霾终将渐渐散开。陈校长以《青春逢盛世，奋斗正当时——做爱国主义的坚定弘扬者和践行者》为主题，通过在线的方式为全校师生上了一堂精彩的思政大课。  </p>
<p><img src="../../../../../files/%E9%9A%8F%E7%AC%94/%E6%80%9D%E6%94%BF%E8%AF%BE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/p1.jpg" alt="听课现场" title="听课现场">  </p>
<a id="more"></a>  

<p>祖国，我们强大的后盾。党中央立足疫情防控的严峻形势，站在统揽全国疫情防控工作和保障人民群众生命安全的高度，作出了应对新冠病毒疫情的重大决策部署，吹响了坚决打赢疫情防控阻击战的冲锋号。中国特色社会主义制度的优越性在于坚持党的领导，在于集中力量办大事，在于始终坚持以人民群众为中心。打赢新冠病毒疫情防控阻击战，就要充分发挥社会主义制度的优越性。  </p>
<p>青春，越是艰险越向前。在新冠疫情防控斗争中，青年人同在一线英勇奋战的广大疫情防空人员一道，不畏艰险，冲锋在前，舍生忘死，彰显了青春的蓬勃力量，交出了合格答卷，广大青年用行动证明，新时代的中国青年是好样的，是堪当大任的。  </p>
<p>爱国，同济人这样传承。同济人与中华民族命运与共，伟大复兴绝不是轻轻松松，敲锣打鼓就能实现的，无数同济人发扬斗争精神，以坚忍不拔的意志和无私无畏的勇气，战胜前进道路上的一切艰难险阻。浓厚的家国情怀和强烈的社会责任感，代代相传，这种爱国精神传承的不仅是知识和文脉，还是一所大学的精神与责任，更是不忘初心牢记使命的写照。  </p>
<p>践行，让青春绽放光彩。同济人乃栋梁之才，擎天之柱，头顶苍穹，脚踏实地，锤炼自身，心怀爱国之志，砥砺报国之行。作为一名即将踏上工作岗位的研究生，要继续在为人民服务中茁壮成长，在艰苦奋斗中砥砺意志品质，在实践中增长工作本领，让青春在党和人民最需要的地方绽放绚丽之花。  </p>
<p>大时代的破局者，注定波澜壮阔。在最好的时代，做一个了不起的梦。  </p>
<p><a href="https://news.tongji.edu.cn/info/1002/73253.htm?from=singlemessage&isappinstalled=0" target="_blank" rel="noopener">链接1</a> <a href="https://mp.weixin.qq.com/s/BDhwYZ70znbtsXZ1ASaz2w" target="_blank" rel="noopener">链接2</a> <a href="https://mp.weixin.qq.com/s/t35x48rMIzRqWss5yj6Enw" target="_blank" rel="noopener">链接3</a> <a href="https://weibointl.api.weibo.cn/share/137409194.html?weibo_id=4488987966322149" target="_blank" rel="noopener">链接4</a>  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>思政</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200404</title>
    <url>/2020/04/04/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200404/</url>
    <content><![CDATA[<p>老家确实不适合长期居住，眼界和心思都跟着变得封闭狭窄，情绪会轻易地受到鸡毛蒜皮邻里间琐碎小事的影响，成了地地道道的小肚鸡肠鼠目寸光的乡下人，这与自命不凡的心中大志是完全相悖的。  </p>
<a id="more"></a>  

<p>原本听起来像是玩笑话的五月份开学也将要变成了现实，三个月余超长寒假消磨着千万学生的意志。事情大致按照预想的方向发展着，在3月20号前通过网络视频会议的方式完成了毕业论文答辩，在严峻疫情的当下依然赶上了往届的进度。在激烈的竞争中也最终拿到了名额有限的上海市优秀毕业生荣誉称号，为学生时代的结束画上完美的句号。申请上海市户籍的积分已累积82分，不需要再为之担心顾虑。  </p>
<p>刚进入同济时，虽是保研但却是倒数第一，与同济本校的同学相比更是实力相差悬殊，对天赋禀异的他们心生敬畏，当然与之并存的是自卑胆怯弱小无助和低人一等。如今已要和这里道别，也终于混出了不比别人差的模样。科研成果，荣誉称号，实习经历和工作签约，都有些许拿得出手得意洋洋的资本。多像是，岁月特别实在，你想要的终会到来。  </p>
<p>连续多日的颓废累计了大批量的愧疚感，科研和Coding能力已接近丧失。  </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>DS-SLAM</title>
    <url>/2020/03/08/PaperReading/DS-SLAM/</url>
    <content><![CDATA[<blockquote>
<p> A Semantic Visual SLAM towards Dynamic Environments  </p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>SLAM系统在动态场景中易受到动态物体的干扰，且创建的地图仅包含几何信息，如路标点地图或点云地图，无法用于高级别的场景理解。  </p>
<p>DS-SLAM结合图像予以分割网络和运动一致性检测，消减场景中动态障碍物的影响，提高定位精度。同时，创建稠密的语义八叉树地图，满足机器人高级别的任务。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p1.png" alt="Overview" title="Overview">  </p>
<a id="more"></a>  

<h2 id="2-Methods"><a href="#2-Methods" class="headerlink" title="2 Methods"></a>2 Methods</h2><h3 id="2-1-Framework"><a href="#2-1-Framework" class="headerlink" title="2.1 Framework"></a>2.1 Framework</h3><p>DS-SLAM在ORB-SLAM2的基础上拓展，系统包含5个并行线程：特征追踪，局部建图，回环检测，稠密语义建图。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p2.png" alt="Framework" title="Framework">  </p>
<h3 id="2-2-Semantic-Segmentation"><a href="#2-2-Semantic-Segmentation" class="headerlink" title="2.2 Semantic Segmentation"></a>2.2 Semantic Segmentation</h3><p>使用SegNet对彩图图像进行语义分割，并仅把行人作为潜在动态物体。  </p>
<h3 id="2-3-Moving-Consistency-Check"><a href="#2-3-Moving-Consistency-Check" class="headerlink" title="2.3 Moving Consistency Check"></a>2.3 Moving Consistency Check</h3><p>根据光流信息查找特征点中是运动的点，具体实现细节不太理解。  </p>
<p>之所以这么做是因为不完全相信语义分割的结果，其对于静止的人身上的特征点是选择保留的。并解释说，语义分割的线程较慢，特征追踪的线程较快，闲着也是闲着，所以增加了这个运动一致性检测的模块。WF??!!  </p>
<h3 id="2-4-Outliers-Rejection"><a href="#2-4-Outliers-Rejection" class="headerlink" title="2.4 Outliers Rejection"></a>2.4 Outliers Rejection</h3><p>结合运动一致性和语义分割信息，仅剔除正在运动的行人身上的特征点对。  </p>
<h3 id="2-5-Dense-Semantic-3D-Octo-tree-Map-Building"><a href="#2-5-Dense-Semantic-3D-Octo-tree-Map-Building" class="headerlink" title="2.5 Dense Semantic 3D Octo-tree Map Building"></a>2.5 Dense Semantic 3D Octo-tree Map Building</h3><p>八叉树地图灵活，紧凑，可更新，存储效率高，便于导航。  </p>
<p>Voxel的语义属性采用概率表达，便于更新。  </p>
<p>由于语义分割的精度有限，且在复杂场景中物体相互遮挡，导致语义分割的结果存在错误。Voxel的存在性使用log-odds值计算更新。  </p>
<h2 id="3-Results"><a href="#3-Results" class="headerlink" title="3 Results"></a>3 Results</h2><p>使用TUM数据集和自采数据进行测试。  </p>
<p>一帧耗时59.4ms，既然是多线程并行，耗时就不应该是各线程耗时和。  </p>
<p>在动态场景中，相比于ORB-SLAM2，定位精度大幅提升。  </p>
<p><img src="../../../../../files/PaperReading/DS_SLAM/p3.png" alt="ORB-SLAM2" title="ORB-SLAM2"><br><img src="../../../../../files/PaperReading/DS_SLAM/p4.png" alt="DS-SLAM" title="DS-SLAM">  </p>
<h2 id="4-Ponder"><a href="#4-Ponder" class="headerlink" title="4 Ponder"></a>4 Ponder</h2><p>a) 运动一致性检测的实现细节?<br>b) Voxel语义属性概率表达如何实现?<br>c) Voxel存在性怎么使用log-odds更新?  </p>
<h2 id="5-More"><a href="#5-More" class="headerlink" title="5 More"></a>5 More</h2><p>Paper：<a href="../../../../../files/PaperReading/DS_SLAM/DS-SLAM_A_Semantic_Visual_SLAM_towards_Dynamic_Environments.pdf">链接</a>  </p>
]]></content>
      <categories>
        <category>PaperReading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>RGB-D</tag>
        <tag>Semantic</tag>
      </tags>
  </entry>
  <entry>
    <title>Loam-livox</title>
    <url>/2020/03/02/PaperReading/Loam-livox/</url>
    <content><![CDATA[<blockquote>
<p>A fast robust high-precision LiDAR odometry and mapping package for LiDARs of small FoV  </p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>相比于传统的机械旋转式Lidar, mems振镜固态式Lidar价格相对低廉, 为Lidar的大规模拓展应用提供更多可能性，成为一大风口.  </p>
<p>固态Lidar特点：<br>1 Small FoV：小视角特征较少易出现退化现象，且易受到动态物体的影响<br>2 Irregular scanning pattern：不规则扫描不利于特征提取, 无法直观有效地获取点间的近邻关系<br>3 Non-repetitive scanning：即使Lidar处于静止状态, 相邻两帧点云也是不同的<br>4 Motion blur：同旋转式Lidar, 连续扫描使得帧内数据获取时间不严格一致  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p4.png" alt="扫描方式" title="扫描方式">  </p>
<p>本文在LOAM的基础上进行拓展，研究内容包括特征提取, 运动补偿, 误关联剔除, 动态物体剔除  </p>
<a id="more"></a>  

<h2 id="2-Methods"><a href="#2-Methods" class="headerlink" title="2 Methods"></a>2 Methods</h2><h3 id="2-1-Points-selection-and-feature-extraction"><a href="#2-1-Points-selection-and-feature-extraction" class="headerlink" title="2.1 Points selection and feature extraction"></a>2.1 Points selection and feature extraction</h3><p>在进行特征提取前, 先筛选剔除以下几类点：视场边缘的点, 反射强度过大或过小的点, 与局部平面夹角近似0°或180°的点 (这里的局部平面怎么得到的呢?), 被遮挡的点 (怎么优雅地遍历呢?).  </p>
<p>特征提取的方法延用LOAM (不规则的扫描方式, 怎么查找点间的近邻关系呢?), 同时考虑反射强度信息, 与近邻点的强度值差别较大的点亦定义为角点.  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p6.png" alt="特征提取与数据关联" title="特征提取与数据关联">  </p>
<h3 id="2-2-Iterative-pose-optimization"><a href="#2-2-Iterative-pose-optimization" class="headerlink" title="2.2 Iterative pose optimization"></a>2.2 Iterative pose optimization</h3><p>延用LOAM中点到线和点到面的数据关联方式. 论文中使用的edge-to-edge和plane-to-plane的说法是不严谨的.  </p>
<p>运动补偿的方法包括piecewise processing和linear interpolation两种. 其中piecewise processing是指将一帧点云按照扫描顺序分为三个sub-frames, 分别独立地对三个sub-frames进行帧与地图的匹配, sub-frames的匹配在并行的三个线程中独立处理 (值得借鉴), 并且试验中证明这种运动补偿的方式更优.  </p>
<p>误匹配和动态物体的剔除在优化求解中统一处理. 迭代优化求解时，在迭代两遍后，然后剔除误差较大的20%的关联，然后再接着迭代优化 (机智啊!).  </p>
<h2 id="3-Results"><a href="#3-Results" class="headerlink" title="3 Results"></a>3 Results</h2><p>建的图好看就完事了~<br><img src="../../../../../files/PaperReading/Loam_livox/p1.png" alt="SLAM_1" title="SLAM_1">  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p2.png" alt="SLAM_2" title="SLAM_2">  </p>
<p><img src="../../../../../files/PaperReading/Loam_livox/p8.png" alt="SLAM_3" title="SLAM_8">  </p>
<h2 id="4-Ponder"><a href="#4-Ponder" class="headerlink" title="4 Ponder"></a>4 Ponder</h2><p>a) 特征提取模块的代码实现细节?<br>b) Piecewise processing中三个独立的子线程如何实现?<br>c) 误匹配和动态物体的剔除技巧值得借鉴呀!  </p>
<h2 id="5-More"><a href="#5-More" class="headerlink" title="5 More"></a>5 More</h2><p>Paper：<a href="../../../../../files/PaperReading/Loam_livox/Loam-livox_A_fast_robust_high-precision_LiDAR_odometry_and_mapping_package_for_LiDARs_of_small_FoV.pdf">链接</a><br>Code：<a href="https://github.com/hku-mars/loam_livox" target="_blank" rel="noopener">链接</a><br>Sensor：<a href="https://www.livoxtech.com/mid-40-and-mid-100" target="_blank" rel="noopener">连接</a></p>
]]></content>
      <categories>
        <category>PaperReading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Lidar</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔_20200216</title>
    <url>/2020/02/16/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94_20200216/</url>
    <content><![CDATA[<blockquote>
<p>在最好的时代，做一个了不起的梦。  </p>
</blockquote>
<p>计划总是被变化甩上几条街的距离。突如其来的疫情扰乱着14亿人的计划。工厂的设备停止运转，工人隔离在家中等待着政府的号令; 学校的教室空空如也，学生以观看直播的方式响应着”停课不停学”的计划; 医院的病房人满为患，医护人员和感染病人争分夺秒地与病毒抗争着。巨大的社会机器像是一列的<a href="https://movie.douban.com/subject/3071441/" target="_blank" rel="noopener">雪国列车</a>，灾难、恐慌、权力、等级、人性等。  </p>
<a id="more"></a>  

<p>最后一个学生时代的假期竟是如此特殊，多次延期使其变得极其漫长。原定于三月份的毕业答辩变得遥遥无期，在诗情画意的樱花大道拍张毕业照定格学生时代的梦想也变为不可能，毕业论文致谢中预言的”冬去春来，已有朵朵早樱点缀着樱花大道，呼唤着樱花盛开的到来，为毕业季增添几分美好与诗意”成了一纸空话。  </p>
<p>可以预想，在一个匆匆的简易毕业典礼后，就要彻底和校园说再见了。或许是20余年的习惯，或许是对安逸生活的依赖，或许是未能满足的自尊心，使得这份别离夹杂着如此多的酸楚。  </p>
<p>身边的很多同事和同学有着博士学历或选择继续攻读博士学位，而自己却就要止步于一名小硕士，如同低人一等的矮个子，和他们交谈时不得不被俯视。曾经为录用Offer薪资的沾沾自喜感已灰飞烟灭，从此之后，优秀等字眼可能将会越走越远，成为一名普普通通的人。  </p>
<p>学习的目的是什么呢？增加技能与提升价值。  </p>
<p>学历和能力的竞争力哪个更胜一筹呢？旗鼓相当。  </p>
<p>深造和就业怎么选择呢？深造，学历和能力是可以兼得的; 就业，当且仅当能力的提升速度是前者的倍数，二者才可相提并论。  </p>
<p>从近一年的实习经历来看，”倍数”的假设是能够成立的。在公司实习的日子是整个研究生阶段最快乐的时光，相比于教研室苦闷、忧愁、焦虑、无作为的生活节奏，在公司研发的感受更多是充实、积极、拼搏、成就。  </p>
<p>既然没有圣人指明前行道路，评判每个选择的正确性，便只能跟随内心凭借直觉摸着石头过河。幻想一下，如同天注定，每一个选择都会在未来的某个日子为之而感动。抛去思想阴霾，制定合理的学习计划，不断提升自身价值。在最好的时代，做一个了不起的梦。 </p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>深造</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建个人博客</title>
    <url>/2020/02/12/%E6%95%99%E7%A8%8B/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>博客是记录成长与进步的最好工具  </p>
</blockquote>
<h2 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1 安装软件"></a>1 安装软件</h2><p>安装git  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure>
<p>安装Node.js  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -</span><br><span class="line">$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>
<p>安装Hexo  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<p>新建工作空间  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>其中_config.yml文件配置网站信息;　source存放用户资源数据;　themes存放博客主题.  </p>
<h2 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h2><p>优雅的主题能够给人带来美感和创作的源泉, 本博客采用的主题为<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a>. 可根据个人审美选择偏爱的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>.首先将主题文件下载到theme文件夹中  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>
<p>将工作空间根目录下的_config.yml中的theme值修改为ayer  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: ayer</span><br></pre></td></tr></table></figure>
<p>其中主题的细节配置可通过修改新下载主题ayer文件夹中的_config.yml文件, 详细内容可参阅<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">ayer官方文档</a>.</p>
<h2 id="3-GitHub配置"><a href="#3-GitHub配置" class="headerlink" title="3 GitHub配置"></a>3 GitHub配置</h2><p>生成GitHub的SSH Key  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"email of github account"</span></span><br></pre></td></tr></table></figure>
<p>复制 ~/.ssh/id_rsa.pub 文件中的内容, 将其粘贴到”GitHub-&gt;Setting-&gt;SSH and GPG Keys-&gt;New SSH key”中, 并新建以”liuhang0727.github.io”命名的仓库.  </p>
<h2 id="4-部署测试"><a href="#4-部署测试" class="headerlink" title="4 部署测试"></a>4 部署测试</h2><p>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>修改工作空间根目录下的_config.yml中的deploy值  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:liuhang0727/liuhang0727.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>远程部署  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入 <a href="https://liuhang0727.github.io" target="_blank" rel="noopener">https://liuhang0727.github.io</a> 即可查看搭建的博客.  </p>
<h2 id="5-新建博客"><a href="#5-新建博客" class="headerlink" title="5 新建博客"></a>5 新建博客</h2><p>可通过命令行新建文章  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new &lt;模板&gt;　&lt;文章名&gt;</span><br></pre></td></tr></table></figure>
<p>其中模板包括post, draft和page三类, 详细介绍可参阅<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>. 新建的文件存放在source/_post/*.md, 可使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>进行Markdown文本编辑, Markdown语法可参考<a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">博客</a>.　在完成创作后, 可发布部署  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>更多信息，请参阅Hexo<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>.  </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<blockquote>
<p>SLAM初级玩家、DL调参侠、自动驾驶幻想师、二流程序员、摄影爱好者</p>
</blockquote>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>姓名: 刘行<br>家乡: 河南漯河<br>现居: 上海杨浦  </p>
<h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><p>2013.09-2017.06　河南理工大学　测绘工程　学士学位<br>2017.09-2020.06　　同济大学　　测绘工程　硕士学位  </p>
<a id="more"></a>  

<h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h3><p>2018.09-2019.09　Momenta　自动驾驶　Lidar高精度定位算法研发  </p>
<h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p>2020.04-今　SenseTime　自动驾驶　自动驾驶系统开发  </p>
<h3 id="论文专利"><a href="#论文专利" class="headerlink" title="论文专利"></a>论文专利</h3><p>[1] <a href="https://www.mdpi.com/2072-4292/11/11/1348" target="_blank" rel="noopener">Liu, H.; Ye, Q.; Wang, H.R.; Chen, L.; Yang, J. A Precise and Robust Segmentation-based Lidar<br>Localization System for Automated Urban Driving. Remote Sensing. 2019, 11, 1348. (SCI，Q1)</a><br>[2] 刘行, 王海瑞, 陈亮. 一种适于交叉路段的道路边沿提取方法及装置. 2019. (已受理)</p>
<h3 id="社交账号"><a href="#社交账号" class="headerlink" title="社交账号"></a>社交账号</h3><p>GitHub: <a href="https://github.com/liuhang0727" target="_blank" rel="noopener">liuhang0727</a><br>E-Mail: <a href="mailto:liuhang@tongji.edu.cn">liuhang@tongji.edu.cn</a><br>CSDN: <a href="https://blog.csdn.net/liudahanghang" target="_blank" rel="noopener">liu_hang_07_27</a><br>知乎: <a href="https://www.zhihu.com/people/liu-xing-52-47-87" target="_blank" rel="noopener">刘行</a><br>豆瓣: <a href="https://www.douban.com/people/185232228/" target="_blank" rel="noopener">刘行</a><br>微博: <a href="https://weibo.com/1819383450/profile?topnav=1&wvr=6" target="_blank" rel="noopener">刘大航航</a><br>微信: <a href="https://wx.qq.com/" target="_blank" rel="noopener">HXXH727</a>  </p>
<p><a href="../files/About/resume_liuhang_20190918.pdf">Resume</a></p>
]]></content>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
